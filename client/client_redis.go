// Code generated by "rediser"; DO NOT EDIT.

package client

type Aggregate string

const (
	AggregateSum Aggregate = "SUM"
	AggregateMin Aggregate = "MIN"
	AggregateMax Aggregate = "MAX"
)

type Clienttype string

const (
	ClienttypeNormal  Clienttype = "normal"
	ClienttypeMaster  Clienttype = "master"
	ClienttypeReplica Clienttype = "replica"
	ClienttypePubsub  Clienttype = "pubsub"
)

type Mode string

const (
	ModeYes  Mode = "YES"
	ModeSync Mode = "SYNC"
	ModeNo   Mode = "NO"
)

type Overflow string

const (
	OverflowWrap Overflow = "WRAP"
	OverflowSat  Overflow = "SAT"
	OverflowFail Overflow = "FAIL"
)

type ReplyMode string

const (
	ReplyModeOn   ReplyMode = "ON"
	ReplyModeOff  ReplyMode = "OFF"
	ReplyModeSkip ReplyMode = "SKIP"
)

type Unit string

const (
	UnitM  Unit = "m"
	UnitKm Unit = "km"
	UnitFt Unit = "ft"
	UnitMi Unit = "mi"
)

type FieldValue struct {
	Field interface{}
	Value interface{}
}
type GroupConsumer struct {
	Group    string
	Consumer string
}
type KeyValue struct {
	Key   interface{}
	Value interface{}
}
type LongitudeLatitudeMember struct {
	Longitude float64
	Latitude  float64
	Member    interface{}
}
type OffsetCount struct {
	Offset int64
	Count  int64
}
type ScoreMember struct {
	Score  float64
	Member interface{}
}
type StartEnd struct {
	Start int64
	End   int64
}
type StartEndCount struct {
	Start string
	End   string
	Count int64
}
type TypeOffset struct {
	Type   string
	Offset int64
}
type TypeOffsetIncrement struct {
	Type      string
	Offset    int64
	Increment int64
}
type TypeOffsetValue struct {
	Type   string
	Offset int64
	Value  int64
}
type UserPassword struct {
	User     string
	Password string
}
type Commands interface {
	ClusterCommands
	ConnectionCommands
	GenericCommands
	GeoCommands
	HashCommands
	HyperloglogCommands
	ListCommands
	PubsubCommands
	ScriptingCommands
	ServerCommands
	SetCommands
	SortedSetCommands
	StreamCommands
	StringCommands
	TransactionsCommands
}
type ClusterCommands interface {
	ClusterAddslots(slot []int64) Result
	ClusterBumpepoch() Result
	ClusterCountFailureReports(nodeId string) Result
	ClusterCountkeysinslot(slot int64) Result
	ClusterDelslots(slot []int64) Result
	ClusterFailover(force *bool) Result
	ClusterFlushslots() Result
	ClusterForget(nodeId string) Result
	ClusterGetkeysinslot(slot, count int64) Result
	ClusterInfo() Result
	ClusterKeyslot(key string) Result
	ClusterMeet(ip string, port int64) Result
	ClusterMyid() Result
	ClusterNodes() Result
	ClusterReplicas(nodeId string) Result
	ClusterReplicate(nodeId string) Result
	ClusterReset(hard *bool) Result
	ClusterSaveconfig() Result
	ClusterSetConfigEpoch(configEpoch int64) Result
	ClusterSetslotImporting(slot int64, sourceNodeId string) Result
	ClusterSetslotMigrating(slot int64, destNodeId string) Result
	ClusterSetslotNode(slot int64, nodeId string) Result
	ClusterSetslotStable(slot int64) Result
	ClusterSlaves(nodeId string) Result
	ClusterSlots() Result
	Readonly() Result
	Readwrite() Result
}
type ConnectionCommands interface {
	AclCat(category *string) Result
	AclDeluser(username []string) Result
	AclGenpass() Result
	AclGetuser(username string) Result
	AclHelp() Result
	AclList() Result
	AclLoad() Result
	AclSave() Result
	AclSetuser(username string, rules []string) Result
	AclUsers() Result
	AclWhoami() Result
	Auth(username *string, password string) Result
	Echo(message string) Result
	Hello(version string, userPassword *UserPassword, clientName *string) Result
	Ping(message *string) Result
	Quit() Result
	Select(index int64) Result
	Swapdb(index1, index2 int64) Result
}
type GenericCommands interface {
	Del(key []interface{}) Result
	Do(v ...interface{}) Result
	Dump(key interface{}) Result
	Exists(key []interface{}) Result
	Expire(key interface{}, seconds int64) Result
	Expireat(key interface{}, timestamp int64) Result
	Keys(pattern string) Result
	Migrate(host, port string, key interface{}, destinationDb, timeout int64, copy, replace bool, auth *string, keys []interface{}) Result
	Move(key interface{}, db int64) Result
	ObjectEncoding(key interface{}) Result
	ObjectFreq(key interface{}) Result
	ObjectHelp() Result
	ObjectIdletime(key interface{}) Result
	ObjectRefcount(key interface{}) Result
	PTTL(key interface{}) Result
	Persist(key interface{}) Result
	Pexpire(key interface{}, milliseconds int64) Result
	Pexpireat(key interface{}, millisecondsTimestamp int64) Result
	Randomkey() Result
	Rename(key, newkey interface{}) Result
	RenameNx(key, newkey interface{}) Result
	Restore(key interface{}, ttl int64, serializedValue string, replace, absttl bool, idletime, freq *int64) Result
	Scan(cursor int64, match *string, count *int64, typ *string) Result
	Sort(key interface{}, by *string, limit *OffsetCount, get []string, asc *bool, sorting bool, store *interface{}) Result
	TTL(key interface{}) Result
	Touch(key []interface{}) Result
	Type(key interface{}) Result
	Unlink(key []interface{}) Result
	Wait(numreplicas, timeout int64) Result
}
type GeoCommands interface {
	Geoadd(key interface{}, longitudeLatitudeMember []LongitudeLatitudeMember) Result
	Geodist(key, member1, member2 interface{}, unit *Unit) Result
	Geohash(key interface{}, member []interface{}) Result
	Geopos(key interface{}, member []interface{}) Result
	Georadius(key interface{}, longitude, latitude, radius float64, unit Unit, withcoord, withdist, withhash bool, count *int64, asc *bool, store, storedist *interface{}) Result
	Georadiusbymember(key, member interface{}, radius float64, unit Unit, withcoord, withdist, withhash bool, count *int64, asc *bool, store, storedist *interface{}) Result
}
type HashCommands interface {
	Hdel(key interface{}, field []interface{}) Result
	Hexists(key, field interface{}) Result
	Hget(key, field interface{}) Result
	Hgetall(key interface{}) Result
	Hincrby(key, field interface{}, increment int64) Result
	Hincrbyfloat(key, field interface{}, increment float64) Result
	Hkeys(key interface{}) Result
	Hlen(key interface{}) Result
	Hmget(key interface{}, field []interface{}) Result
	Hscan(key interface{}, cursor int64, match *string, count *int64) Result
	Hset(key interface{}, fieldValue []FieldValue) Result
	HsetNx(key, field, value interface{}) Result
	Hstrlen(key, field interface{}) Result
	Hvals(key interface{}) Result
}
type HyperloglogCommands interface {
	Pfadd(key interface{}, element []interface{}) Result
	Pfcount(key []interface{}) Result
	Pfmerge(destkey interface{}, sourcekey []interface{}) Result
}
type ListCommands interface {
	Blpop(key []interface{}, timeout int64) Result
	Brpop(key []interface{}, timeout int64) Result
	Brpoplpush(source, destination interface{}, timeout int64) Result
	Lindex(key interface{}, index int64) Result
	Linsert(key interface{}, before bool, pivot, element interface{}) Result
	Llen(key interface{}) Result
	Lpop(key interface{}) Result
	Lpush(key interface{}, element []interface{}) Result
	Lpushx(key interface{}, element []interface{}) Result
	Lrange(key interface{}, start, stop int64) Result
	Lrem(key interface{}, count int64, element interface{}) Result
	Lset(key interface{}, index int64, element interface{}) Result
	Ltrim(key interface{}, start, stop int64) Result
	Rpop(key interface{}) Result
	Rpoplpush(source, destination interface{}) Result
	Rpush(key interface{}, element []interface{}) Result
	Rpushx(key interface{}, element []interface{}) Result
}
type PubsubCommands interface {
	Psubscribe(pattern []string, cb MsgCallback) Result
	Publish(channel, message string) Result
	PubsubChannels(pattern *string) Result
	PubsubNumpat() Result
	PubsubNumsub(channel []string) Result
	Punsubscribe(pattern []string) Result
	Subscribe(channel []string, cb MsgCallback) Result
	Unsubscribe(channel []string) Result
}
type ScriptingCommands interface {
	Eval(script string, numkeys int64, key, arg []interface{}) Result
	Evalsha(sha1 string, numkeys int64, key, arg []interface{}) Result
	ScriptDebug(mode Mode) Result
	ScriptExists(sha1 []string) Result
	ScriptFlush() Result
	ScriptKill() Result
	ScriptLoad(script string) Result
}
type ServerCommands interface {
	Bgrewriteaof() Result
	Bgsave() Result
	ClientGetname() Result
	ClientId() Result
	ClientKill(id *int64, typ *Clienttype, addr *string, skipme bool) Result
	ClientList(typ *Clienttype) Result
	ClientPause(timeout int64) Result
	ClientReply(replyMode ReplyMode) Result
	ClientSetname(connectionName string) Result
	ClientTracking(on bool, redirect *int64) Result
	ClientUnblock(clientId int64, timeout *bool) Result
	Command() Result
	CommandCount() Result
	CommandGetkeys(arg []interface{}) Result
	CommandInfo(commandName []string) Result
	ConfigGet(parameter string) Result
	ConfigResetstat() Result
	ConfigRewrite() Result
	ConfigSet(parameter, value string) Result
	Dbsize() Result
	DebugObject(key interface{}) Result
	DebugSegfault() Result
	Flushall(async bool) Result
	Flushdb(async bool) Result
	Info(section *string) Result
	Lastsave() Result
	LatencyDoctor() Result
	LatencyGraph(event string) Result
	LatencyHelp() Result
	LatencyHistory(event string) Result
	LatencyLatest() Result
	LatencyReset(event *string) Result
	Lolwut(version *int64) Result
	MemoryDoctor() Result
	MemoryHelp() Result
	MemoryMallocStats() Result
	MemoryPurge() Result
	MemoryStats() Result
	MemoryUsage(key interface{}, samples *int64) Result
	ModuleList() Result
	ModuleLoad(path string, arg []string) Result
	ModuleUnload(name string) Result
	Monitor() Result
	Psync(replicationid, offset int64) Result
	Replicaof(host, port string) Result
	Role() Result
	Save() Result
	Shutdown(nosave *bool) Result
	SlowlogGet(count *int64) Result
	SlowlogLen() Result
	SlowlogReset() Result
	Time() Result
}
type SetCommands interface {
	Sadd(key interface{}, member []interface{}) Result
	Scard(key interface{}) Result
	Sdiff(key []interface{}) Result
	Sdiffstore(destination interface{}, key []interface{}) Result
	Sinter(key []interface{}) Result
	Sinterstore(destination interface{}, key []interface{}) Result
	Sismember(key, member interface{}) Result
	Smembers(key interface{}) Result
	Smove(source, destination, member interface{}) Result
	Spop(key interface{}, count *int64) Result
	Srandmember(key interface{}, count *int64) Result
	Srem(key interface{}, member []interface{}) Result
	Sscan(key interface{}, cursor int64, match *string, count *int64) Result
	Sunion(key []interface{}) Result
	Sunionstore(destination interface{}, key []interface{}) Result
}
type SortedSetCommands interface {
	Bzpopmax(key []interface{}, timeout int64) Result
	Bzpopmin(key []interface{}, timeout int64) Result
	Zadd(key interface{}, scoreMember []ScoreMember) Result
	ZaddCh(key interface{}, scoreMember []ScoreMember) Result
	ZaddNx(key interface{}, scoreMember []ScoreMember) Result
	ZaddXx(key interface{}, scoreMember []ScoreMember) Result
	ZaddXxCh(key interface{}, scoreMember []ScoreMember) Result
	Zcard(key interface{}) Result
	Zcount(key interface{}, min, max Zfloat64) Result
	Zincrby(key interface{}, increment float64, member interface{}) Result
	Zinterstore(destination interface{}, numkeys int64, key []interface{}, weights []int64, aggregate *Aggregate) Result
	Zlexcount(key interface{}, min, max string) Result
	Zpopmax(key interface{}, count *int64) Result
	Zpopmin(key interface{}, count *int64) Result
	Zrange(key interface{}, start, stop int64, withscores bool) Result
	Zrangebylex(key interface{}, min, max string, limit *OffsetCount) Result
	Zrangebyscore(key interface{}, min, max Zfloat64, withscores bool, limit *OffsetCount) Result
	Zrank(key, member interface{}) Result
	Zrem(key interface{}, member []interface{}) Result
	Zremrangebylex(key interface{}, min, max string) Result
	Zremrangebyrank(key interface{}, start, stop int64) Result
	Zremrangebyscore(key interface{}, min, max Zfloat64) Result
	Zrevrange(key interface{}, start, stop int64, withscores bool) Result
	Zrevrangebylex(key interface{}, max, min string, limit *OffsetCount) Result
	Zrevrangebyscore(key interface{}, max, min Zfloat64, withscores bool, limit *OffsetCount) Result
	Zrevrank(key, member interface{}) Result
	Zscan(key interface{}, cursor int64, match *string, count *int64) Result
	Zscore(key, member interface{}) Result
	Zunionstore(destination interface{}, numkeys int64, key []interface{}, weights []int64, aggregate *Aggregate) Result
}
type StreamCommands interface {
	Xack(key interface{}, group string, id []string) Result
	Xadd(key interface{}, id string, fieldValue []FieldValue) Result
	Xclaim(key interface{}, group, consumer, minIdleTime string, id []string, idle, time, retrycount *int64, force, justid bool) Result
	Xdel(key interface{}, id []string) Result
	XgroupCreate(key interface{}, groupname, id string, mkstream bool) Result
	XgroupDelconsumer(key interface{}, groupname, consumername string) Result
	XgroupDestroy(key interface{}, groupname string) Result
	XgroupHelp() Result
	XgroupSetid(key interface{}, groupname, id string) Result
	XinfoConsumers(key interface{}, groupname string) Result
	XinfoGroups(key interface{}) Result
	XinfoHelp() Result
	XinfoStream(key interface{}) Result
	Xlen(key interface{}) Result
	Xpending(key interface{}, group string, startEndCount *StartEndCount, consumer *string) Result
	Xrange(key interface{}, start, end string, count *int64) Result
	Xread(count, block *int64, key []interface{}, id []string) Result
	Xreadgroup(group GroupConsumer, count, block *int64, noack bool, key []interface{}, id []string) Result
	Xrevrange(key interface{}, end, start string, count *int64) Result
	Xtrim(key interface{}, approx bool, count int64) Result
}
type StringCommands interface {
	Append(key, value interface{}) Result
	Bitcount(key interface{}, startEnd *StartEnd) Result
	Bitfield(key interface{}, operation []interface{}) Result
	BitopAnd(destkey interface{}, srckey []interface{}) Result
	BitopNot(destkey, srckey interface{}) Result
	BitopOr(destkey interface{}, srckey []interface{}) Result
	BitopXor(destkey interface{}, srckey []interface{}) Result
	Bitpos(key interface{}, bit int64, start, end *int64) Result
	Decr(key interface{}) Result
	Decrby(key interface{}, decrement int64) Result
	Get(key interface{}) Result
	Getbit(key interface{}, offset int64) Result
	Getrange(key interface{}, start, end int64) Result
	Getset(key, value interface{}) Result
	Incr(key interface{}) Result
	Incrby(key interface{}, increment int64) Result
	Incrbyfloat(key interface{}, increment float64) Result
	Mget(key []interface{}) Result
	Mset(keyValue []KeyValue) Result
	MsetNx(keyValue []KeyValue) Result
	Set(key, value interface{}) Result
	SetEx(key, value interface{}, seconds int64) Result
	SetExNx(key, value interface{}, seconds int64) Result
	SetExXx(key, value interface{}, seconds int64) Result
	SetNx(key, value interface{}) Result
	SetPx(key, value interface{}, milliseconds int64) Result
	SetPxNx(key, value interface{}, milliseconds int64) Result
	SetPxXx(key, value interface{}, milliseconds int64) Result
	SetXx(key, value interface{}) Result
	Setbit(key interface{}, offset, value int64) Result
	Setrange(key interface{}, offset int64, value interface{}) Result
	Strlen(key interface{}) Result
}
type TransactionsCommands interface {
	Discard() Result
	Exec() Result
	Multi() Result
	Unwatch() Result
	Watch(key []interface{}) Result
}

// AclCat - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclCat(category *string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "CAT")
	if category != nil {
		c.encode(category)
	}
	c.send(CmdAclCat, r)
	return r
}

// AclDeluser - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclDeluser(username []string) Result {
	r := newAsyncResult()
	if username == nil {
		r.setErr(newInvalidValueError("username", nil))
		return r
	}
	c.mu.Lock()
	c.encode("ACL", "DELUSER")
	for _, v := range username {
		c.encode(v)
	}
	c.send(CmdAclDeluser, r)
	return r
}

// AclGenpass - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclGenpass() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "GENPASS")
	c.send(CmdAclGenpass, r)
	return r
}

// AclGetuser - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclGetuser(username string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "GETUSER", username)
	c.send(CmdAclGetuser, r)
	return r
}

// AclHelp - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclHelp() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "HELP")
	c.send(CmdAclHelp, r)
	return r
}

// AclList - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclList() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "LIST")
	c.send(CmdAclList, r)
	return r
}

// AclLoad - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclLoad() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "LOAD")
	c.send(CmdAclLoad, r)
	return r
}

// AclSave - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclSave() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "SAVE")
	c.send(CmdAclSave, r)
	return r
}

// AclSetuser - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclSetuser(username string, rules []string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "SETUSER", username)
	for _, v := range rules {
		c.encode(v)
	}
	c.send(CmdAclSetuser, r)
	return r
}

// AclUsers - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclUsers() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "USERS")
	c.send(CmdAclUsers, r)
	return r
}

// AclWhoami - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) AclWhoami() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ACL", "WHOAMI")
	c.send(CmdAclWhoami, r)
	return r
}

// Append - Append a value to a key
// Group: string
// Since: 2.0.0
// Complexity:
// O(1). The amortized time complexity is O(1) assuming the appended value is
// small and the already present value is of any size, since the dynamic string library
// used by Redis will double the free space available on every reallocation.
func (c *command) Append(key, value interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("APPEND", key, value)
	c.send(CmdAppend, r)
	return r
}

// Auth - Authenticate to the server
// Group: connection
// Since: 1.0.0
func (c *command) Auth(username *string, password string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("AUTH")
	if username != nil {
		c.encode(username)
	}
	c.encode(password)
	c.send(CmdAuth, r)
	return r
}

// Bgrewriteaof - Asynchronously rewrite the append-only file
// Group: server
// Since: 1.0.0
func (c *command) Bgrewriteaof() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("BGREWRITEAOF")
	c.send(CmdBgrewriteaof, r)
	return r
}

// Bgsave - Asynchronously save the dataset to disk
// Group: server
// Since: 1.0.0
func (c *command) Bgsave() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("BGSAVE")
	c.send(CmdBgsave, r)
	return r
}

// Bitcount - Count set bits in a string
// Group: string
// Since: 2.6.0
// Complexity: O(N)
func (c *command) Bitcount(key interface{}, startEnd *StartEnd) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("BITCOUNT", key)
	if startEnd != nil {
		c.encode(startEnd.Start, startEnd.End)
	}
	c.send(CmdBitcount, r)
	return r
}

// Bitfield - Perform arbitrary bitfield integer operations on strings
// Group: string
// Since: 3.2.0
// Complexity: O(1) for each subcommand specified
func (c *command) Bitfield(key interface{}, operation []interface{}) Result {
	r := newAsyncResult()
	if operation == nil {
		r.setErr(newInvalidValueError("operation", nil))
		return r
	}
	c.mu.Lock()
	c.encode("BITFIELD", key)
	for _, v := range operation {
		switch v := v.(type) {
		case TypeOffset:
			c.encode("GET", v.Type, v.Offset)
		case TypeOffsetValue:
			c.encode("SET", v.Type, v.Offset, v.Value)
		case TypeOffsetIncrement:
			c.encode("INCRBY", v.Type, v.Offset, v.Increment)
		case Overflow:
			c.encode("OVERFLOW", v)
		case *TypeOffset:
			c.encode("GET", v.Type, v.Offset)
		case *TypeOffsetValue:
			c.encode("SET", v.Type, v.Offset, v.Value)
		case *TypeOffsetIncrement:
			c.encode("INCRBY", v.Type, v.Offset, v.Increment)
		case *Overflow:
			c.encode("OVERFLOW", v)
		default:
			r.setErr(newInvalidValueError("operation", v))
		}
	}
	c.send(CmdBitfield, r)
	return r
}

// BitopAnd - Perform bitwise operations between strings
// Group: string
// Since: 2.6.0
// Complexity: O(N)
func (c *command) BitopAnd(destkey interface{}, srckey []interface{}) Result {
	r := newAsyncResult()
	if srckey == nil {
		r.setErr(newInvalidValueError("srckey", nil))
		return r
	}
	c.mu.Lock()
	c.encode("BITOP", "AND", destkey)
	for _, v := range srckey {
		c.encode(v)
	}
	c.send(CmdBitopAnd, r)
	return r
}

// BitopNot - Perform bitwise operations between strings
// Group: string
// Since: 2.6.0
// Complexity: O(N)
func (c *command) BitopNot(destkey, srckey interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("BITOP", "NOT", destkey, srckey)
	c.send(CmdBitopNot, r)
	return r
}

// BitopOr - Perform bitwise operations between strings
// Group: string
// Since: 2.6.0
// Complexity: O(N)
func (c *command) BitopOr(destkey interface{}, srckey []interface{}) Result {
	r := newAsyncResult()
	if srckey == nil {
		r.setErr(newInvalidValueError("srckey", nil))
		return r
	}
	c.mu.Lock()
	c.encode("BITOP", "OR", destkey)
	for _, v := range srckey {
		c.encode(v)
	}
	c.send(CmdBitopOr, r)
	return r
}

// BitopXor - Perform bitwise operations between strings
// Group: string
// Since: 2.6.0
// Complexity: O(N)
func (c *command) BitopXor(destkey interface{}, srckey []interface{}) Result {
	r := newAsyncResult()
	if srckey == nil {
		r.setErr(newInvalidValueError("srckey", nil))
		return r
	}
	c.mu.Lock()
	c.encode("BITOP", "XOR", destkey)
	for _, v := range srckey {
		c.encode(v)
	}
	c.send(CmdBitopXor, r)
	return r
}

// Bitpos - Find first bit set or clear in a string
// Group: string
// Since: 2.8.7
// Complexity: O(N)
func (c *command) Bitpos(key interface{}, bit int64, start, end *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("BITPOS", key, bit)
	if start != nil {
		c.encode(start)
	}
	if end != nil {
		c.encode(end)
	}
	c.send(CmdBitpos, r)
	return r
}

// Blpop - Remove and get the first element in a list, or block until one is available
// Group: list
// Since: 2.0.0
// Complexity: O(1)
func (c *command) Blpop(key []interface{}, timeout int64) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("BLPOP")
	for _, v := range key {
		c.encode(v)
	}
	c.encode(timeout)
	c.send(CmdBlpop, r)
	return r
}

// Brpop - Remove and get the last element in a list, or block until one is available
// Group: list
// Since: 2.0.0
// Complexity: O(1)
func (c *command) Brpop(key []interface{}, timeout int64) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("BRPOP")
	for _, v := range key {
		c.encode(v)
	}
	c.encode(timeout)
	c.send(CmdBrpop, r)
	return r
}

// Brpoplpush - Pop an element from a list, push it to another list and return it; or block until one is available
// Group: list
// Since: 2.2.0
// Complexity: O(1)
func (c *command) Brpoplpush(source, destination interface{}, timeout int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("BRPOPLPUSH", source, destination, timeout)
	c.send(CmdBrpoplpush, r)
	return r
}

// Bzpopmax - Remove and return the member with the highest score from one or more sorted sets, or block until one is available
// Group: sorted_set
// Since: 5.0.0
// Complexity: O(log(N)) with N being the number of elements in the sorted set.
func (c *command) Bzpopmax(key []interface{}, timeout int64) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("BZPOPMAX")
	for _, v := range key {
		c.encode(v)
	}
	c.encode(timeout)
	c.send(CmdBzpopmax, r)
	return r
}

// Bzpopmin - Remove and return the member with the lowest score from one or more sorted sets, or block until one is available
// Group: sorted_set
// Since: 5.0.0
// Complexity: O(log(N)) with N being the number of elements in the sorted set.
func (c *command) Bzpopmin(key []interface{}, timeout int64) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("BZPOPMIN")
	for _, v := range key {
		c.encode(v)
	}
	c.encode(timeout)
	c.send(CmdBzpopmin, r)
	return r
}

// ClientGetname - Get the current connection name
// Group: server
// Since: 2.6.9
// Complexity: O(1)
func (c *command) ClientGetname() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLIENT", "GETNAME")
	c.send(CmdClientGetname, r)
	return r
}

// ClientId - Returns the client ID for the current connection
// Group: server
// Since: 5.0.0
// Complexity: O(1)
func (c *command) ClientId() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLIENT", "ID")
	c.send(CmdClientId, r)
	return r
}

// ClientKill - Kill the connection of a client
// Group: server
// Since: 2.4.0
// Complexity: O(N) where N is the number of client connections
func (c *command) ClientKill(id *int64, typ *Clienttype, addr *string, skipme bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLIENT", "KILL")
	if id != nil {
		c.encode("ID", id)
	}
	if typ != nil {
		c.encode("TYPE", typ)
	}
	if addr != nil {
		c.encode("ADDR", addr)
	}
	if skipme {
		c.encode("SKIPME", "YES")
	} else {
		c.encode("SKIPME", "NO")
	}
	c.send(CmdClientKill, r)
	return r
}

// ClientList - Get the list of client connections
// Group: server
// Since: 2.4.0
// Complexity: O(N) where N is the number of client connections
func (c *command) ClientList(typ *Clienttype) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLIENT", "LIST")
	if typ != nil {
		c.encode("TYPE", typ)
	}
	c.send(CmdClientList, r)
	return r
}

// ClientPause - Stop processing commands from clients for some time
// Group: server
// Since: 2.9.50
// Complexity: O(1)
func (c *command) ClientPause(timeout int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLIENT", "PAUSE", timeout)
	c.send(CmdClientPause, r)
	return r
}

// ClientReply - Instruct the server whether to reply to commands
// Group: server
// Since: 3.2
// Complexity: O(1)
func (c *command) ClientReply(replyMode ReplyMode) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLIENT", "REPLY", replyMode)
	c.send(CmdClientReply, r)
	return r
}

// ClientSetname - Set the current connection name
// Group: server
// Since: 2.6.9
// Complexity: O(1)
func (c *command) ClientSetname(connectionName string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLIENT", "SETNAME", connectionName)
	c.send(CmdClientSetname, r)
	return r
}

// ClientTracking - Enable client side caching.
// Group: server
// Since: 6.0.0
func (c *command) ClientTracking(on bool, redirect *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLIENT", "TRACKING")
	if on {
		c.encode("ON")
	} else {
		c.encode("OFF")
	}
	if redirect != nil {
		c.encode("REDIRECT", redirect)
	}
	c.send(CmdClientTracking, r)
	return r
}

// ClientUnblock - Unblock a client blocked in a blocking command from a different connection
// Group: server
// Since: 5.0.0
// Complexity: O(log N) where N is the number of client connections
func (c *command) ClientUnblock(clientId int64, timeout *bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLIENT", "UNBLOCK", clientId)
	if timeout != nil {
		if *timeout {
			c.encode("TIMEOUT")
		} else {
			c.encode("ERROR")
		}
	}
	c.send(CmdClientUnblock, r)
	return r
}

// ClusterAddslots - Assign new hash slots to receiving node
// Group: cluster
// Since: 3.0.0
// Complexity: O(N) where N is the total number of hash slot arguments
func (c *command) ClusterAddslots(slot []int64) Result {
	r := newAsyncResult()
	if slot == nil {
		r.setErr(newInvalidValueError("slot", nil))
		return r
	}
	c.mu.Lock()
	c.encode("CLUSTER", "ADDSLOTS")
	for _, v := range slot {
		c.encode(v)
	}
	c.send(CmdClusterAddslots, r)
	return r
}

// ClusterBumpepoch - Advance the cluster config epoch
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterBumpepoch() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "BUMPEPOCH")
	c.send(CmdClusterBumpepoch, r)
	return r
}

// ClusterCountFailureReports - Return the number of failure reports active for a given node
// Group: cluster
// Since: 3.0.0
// Complexity: O(N) where N is the number of failure reports
func (c *command) ClusterCountFailureReports(nodeId string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "COUNT-FAILURE-REPORTS", nodeId)
	c.send(CmdClusterCountFailureReports, r)
	return r
}

// ClusterCountkeysinslot - Return the number of local keys in the specified hash slot
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterCountkeysinslot(slot int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "COUNTKEYSINSLOT", slot)
	c.send(CmdClusterCountkeysinslot, r)
	return r
}

// ClusterDelslots - Set hash slots as unbound in receiving node
// Group: cluster
// Since: 3.0.0
// Complexity: O(N) where N is the total number of hash slot arguments
func (c *command) ClusterDelslots(slot []int64) Result {
	r := newAsyncResult()
	if slot == nil {
		r.setErr(newInvalidValueError("slot", nil))
		return r
	}
	c.mu.Lock()
	c.encode("CLUSTER", "DELSLOTS")
	for _, v := range slot {
		c.encode(v)
	}
	c.send(CmdClusterDelslots, r)
	return r
}

// ClusterFailover - Forces a replica to perform a manual failover of its master.
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterFailover(force *bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "FAILOVER")
	if force != nil {
		if *force {
			c.encode("FORCE")
		} else {
			c.encode("TAKEOVER")
		}
	}
	c.send(CmdClusterFailover, r)
	return r
}

// ClusterFlushslots - Delete a node's own slots information
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterFlushslots() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "FLUSHSLOTS")
	c.send(CmdClusterFlushslots, r)
	return r
}

// ClusterForget - Remove a node from the nodes table
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterForget(nodeId string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "FORGET", nodeId)
	c.send(CmdClusterForget, r)
	return r
}

// ClusterGetkeysinslot - Return local key names in the specified hash slot
// Group: cluster
// Since: 3.0.0
// Complexity: O(log(N)) where N is the number of requested keys
func (c *command) ClusterGetkeysinslot(slot, count int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "GETKEYSINSLOT", slot, count)
	c.send(CmdClusterGetkeysinslot, r)
	return r
}

// ClusterInfo - Provides info about Redis Cluster node state
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterInfo() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "INFO")
	c.send(CmdClusterInfo, r)
	return r
}

// ClusterKeyslot - Returns the hash slot of the specified key
// Group: cluster
// Since: 3.0.0
// Complexity: O(N) where N is the number of bytes in the key
func (c *command) ClusterKeyslot(key string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "KEYSLOT", key)
	c.send(CmdClusterKeyslot, r)
	return r
}

// ClusterMeet - Force a node cluster to handshake with another node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterMeet(ip string, port int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "MEET", ip, port)
	c.send(CmdClusterMeet, r)
	return r
}

// ClusterMyid - Return the node id
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterMyid() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "MYID")
	c.send(CmdClusterMyid, r)
	return r
}

// ClusterNodes - Get Cluster config for the node
// Group: cluster
// Since: 3.0.0
// Complexity: O(N) where N is the total number of Cluster nodes
func (c *command) ClusterNodes() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "NODES")
	c.send(CmdClusterNodes, r)
	return r
}

// ClusterReplicas - List replica nodes of the specified master node
// Group: cluster
// Since: 5.0.0
// Complexity: O(1)
func (c *command) ClusterReplicas(nodeId string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "REPLICAS", nodeId)
	c.send(CmdClusterReplicas, r)
	return r
}

// ClusterReplicate - Reconfigure a node as a replica of the specified master node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterReplicate(nodeId string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "REPLICATE", nodeId)
	c.send(CmdClusterReplicate, r)
	return r
}

// ClusterReset - Reset a Redis Cluster node
// Group: cluster
// Since: 3.0.0
// Complexity:
// O(N) where N is the number of known nodes. The command may execute a FLUSHALL
// as a side effect.
func (c *command) ClusterReset(hard *bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "RESET")
	if hard != nil {
		if *hard {
			c.encode("HARD")
		} else {
			c.encode("SOFT")
		}
	}
	c.send(CmdClusterReset, r)
	return r
}

// ClusterSaveconfig - Forces the node to save cluster state on disk
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterSaveconfig() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "SAVECONFIG")
	c.send(CmdClusterSaveconfig, r)
	return r
}

// ClusterSetConfigEpoch - Set the configuration epoch in a new node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterSetConfigEpoch(configEpoch int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "SET-CONFIG-EPOCH", configEpoch)
	c.send(CmdClusterSetConfigEpoch, r)
	return r
}

// ClusterSetslotImporting - Bind a hash slot to a specific node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterSetslotImporting(slot int64, sourceNodeId string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "SETSLOT", slot, "IMPORTING", sourceNodeId)
	c.send(CmdClusterSetslotImporting, r)
	return r
}

// ClusterSetslotMigrating - Bind a hash slot to a specific node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterSetslotMigrating(slot int64, destNodeId string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "SETSLOT", slot, "MIGRATING", destNodeId)
	c.send(CmdClusterSetslotMigrating, r)
	return r
}

// ClusterSetslotNode - Bind a hash slot to a specific node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterSetslotNode(slot int64, nodeId string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "SETSLOT", slot, "NODE", nodeId)
	c.send(CmdClusterSetslotNode, r)
	return r
}

// ClusterSetslotStable - Bind a hash slot to a specific node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterSetslotStable(slot int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "SETSLOT", slot, "STABLE")
	c.send(CmdClusterSetslotStable, r)
	return r
}

// ClusterSlaves - List replica nodes of the specified master node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) ClusterSlaves(nodeId string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "SLAVES", nodeId)
	c.send(CmdClusterSlaves, r)
	return r
}

// ClusterSlots - Get array of Cluster slot to node mappings
// Group: cluster
// Since: 3.0.0
// Complexity: O(N) where N is the total number of Cluster nodes
func (c *command) ClusterSlots() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CLUSTER", "SLOTS")
	c.send(CmdClusterSlots, r)
	return r
}

// Command - Get array of Redis command details
// Group: server
// Since: 2.8.13
// Complexity: O(N) where N is the total number of Redis commands
func (c *command) Command() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("COMMAND")
	c.send(CmdCommand, r)
	return r
}

// CommandCount - Get total number of Redis commands
// Group: server
// Since: 2.8.13
// Complexity: O(1)
func (c *command) CommandCount() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("COMMAND", "COUNT")
	c.send(CmdCommandCount, r)
	return r
}

// CommandGetkeys - Extract keys given a full Redis command
// Group: server
// Since: 2.8.13
// Complexity: O(N) where N is the number of arguments to the command
func (c *command) CommandGetkeys(arg []interface{}) Result {
	r := newAsyncResult()
	if arg == nil {
		r.setErr(newInvalidValueError("arg", nil))
		return r
	}
	c.mu.Lock()
	c.encode("COMMAND", "GETKEYS")
	for _, v := range arg {
		c.encode(v)
	}
	c.send(CmdCommandGetkeys, r)
	return r
}

// CommandInfo - Get array of specific Redis command details
// Group: server
// Since: 2.8.13
// Complexity: O(N) when N is number of commands to look up
func (c *command) CommandInfo(commandName []string) Result {
	r := newAsyncResult()
	if commandName == nil {
		r.setErr(newInvalidValueError("commandName", nil))
		return r
	}
	c.mu.Lock()
	c.encode("COMMAND", "INFO")
	for _, v := range commandName {
		c.encode(v)
	}
	c.send(CmdCommandInfo, r)
	return r
}

// ConfigGet - Get the value of a configuration parameter
// Group: server
// Since: 2.0.0
func (c *command) ConfigGet(parameter string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CONFIG", "GET", parameter)
	c.send(CmdConfigGet, r)
	return r
}

// ConfigResetstat - Reset the stats returned by INFO
// Group: server
// Since: 2.0.0
// Complexity: O(1)
func (c *command) ConfigResetstat() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CONFIG", "RESETSTAT")
	c.send(CmdConfigResetstat, r)
	return r
}

// ConfigRewrite - Rewrite the configuration file with the in memory configuration
// Group: server
// Since: 2.8.0
func (c *command) ConfigRewrite() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CONFIG", "REWRITE")
	c.send(CmdConfigRewrite, r)
	return r
}

// ConfigSet - Set a configuration parameter to the given value
// Group: server
// Since: 2.0.0
func (c *command) ConfigSet(parameter, value string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("CONFIG", "SET", parameter, value)
	c.send(CmdConfigSet, r)
	return r
}

// Dbsize - Return the number of keys in the selected database
// Group: server
// Since: 1.0.0
func (c *command) Dbsize() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("DBSIZE")
	c.send(CmdDbsize, r)
	return r
}

// DebugObject - Get debugging information about a key
// Group: server
// Since: 1.0.0
func (c *command) DebugObject(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("DEBUG", "OBJECT", key)
	c.send(CmdDebugObject, r)
	return r
}

// DebugSegfault - Make the server crash
// Group: server
// Since: 1.0.0
func (c *command) DebugSegfault() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("DEBUG", "SEGFAULT")
	c.send(CmdDebugSegfault, r)
	return r
}

// Decr - Decrement the integer value of a key by one
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Decr(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("DECR", key)
	c.send(CmdDecr, r)
	return r
}

// Decrby - Decrement the integer value of a key by the given number
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Decrby(key interface{}, decrement int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("DECRBY", key, decrement)
	c.send(CmdDecrby, r)
	return r
}

// Del - Delete a key
// Group: generic
// Since: 1.0.0
// Complexity:
// O(N) where N is the number of keys that will be removed. When a key to remove
// holds a value other than a string, the individual complexity for this key is O(M)
// where M is the number of elements in the list, set, sorted set or hash. Removing a
// single key that holds a string value is O(1).
func (c *command) Del(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("DEL")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdDel, r)
	return r
}

// Discard - Discard all commands issued after MULTI
// Group: transactions
// Since: 2.0.0
func (c *command) Discard() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("DISCARD")
	c.send(CmdDiscard, r)
	return r
}

// Do - Generic command.
// Group: generic
// Since: -
func (c *command) Do(v ...interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode(v...)
	c.send(CmdDo, r)
	return r
}

// Dump - Return a serialized version of the value stored at the specified key.
// Group: generic
// Since: 2.6.0
// Complexity:
// O(1) to access the key and additional O(N*M) to serialized it, where N is the
// number of Redis objects composing the value and M their average size. For small string
// values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).
func (c *command) Dump(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("DUMP", key)
	c.send(CmdDump, r)
	return r
}

// Echo - Echo the given string
// Group: connection
// Since: 1.0.0
func (c *command) Echo(message string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ECHO", message)
	c.send(CmdEcho, r)
	return r
}

// Eval - Execute a Lua script server side
// Group: scripting
// Since: 2.6.0
// Complexity: Depends on the script that is executed.
func (c *command) Eval(script string, numkeys int64, key, arg []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	if arg == nil {
		r.setErr(newInvalidValueError("arg", nil))
		return r
	}
	c.mu.Lock()
	c.encode("EVAL", script, numkeys)
	for _, v := range key {
		c.encode(v)
	}
	for _, v := range arg {
		c.encode(v)
	}
	c.send(CmdEval, r)
	return r
}

// Evalsha - Execute a Lua script server side
// Group: scripting
// Since: 2.6.0
// Complexity: Depends on the script that is executed.
func (c *command) Evalsha(sha1 string, numkeys int64, key, arg []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	if arg == nil {
		r.setErr(newInvalidValueError("arg", nil))
		return r
	}
	c.mu.Lock()
	c.encode("EVALSHA", sha1, numkeys)
	for _, v := range key {
		c.encode(v)
	}
	for _, v := range arg {
		c.encode(v)
	}
	c.send(CmdEvalsha, r)
	return r
}

// Exec - Execute all commands issued after MULTI
// Group: transactions
// Since: 1.2.0
func (c *command) Exec() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("EXEC")
	c.send(CmdExec, r)
	return r
}

// Exists - Determine if a key exists
// Group: generic
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Exists(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("EXISTS")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdExists, r)
	return r
}

// Expire - Set a key's time to live in seconds
// Group: generic
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Expire(key interface{}, seconds int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("EXPIRE", key, seconds)
	c.send(CmdExpire, r)
	return r
}

// Expireat - Set the expiration for a key as a UNIX timestamp
// Group: generic
// Since: 1.2.0
// Complexity: O(1)
func (c *command) Expireat(key interface{}, timestamp int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("EXPIREAT", key, timestamp)
	c.send(CmdExpireat, r)
	return r
}

// Flushall - Remove all keys from all databases
// Group: server
// Since: 1.0.0
func (c *command) Flushall(async bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("FLUSHALL")
	if async {
		c.encode("ASYNC")
	}
	c.send(CmdFlushall, r)
	return r
}

// Flushdb - Remove all keys from the current database
// Group: server
// Since: 1.0.0
func (c *command) Flushdb(async bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("FLUSHDB")
	if async {
		c.encode("ASYNC")
	}
	c.send(CmdFlushdb, r)
	return r
}

// Geoadd - Add one or more geospatial items in the geospatial index represented using a sorted set
// Group: geo
// Since: 3.2.0
// Complexity:
// O(log(N)) for each item added, where N is the number of elements in the sorted
// set.
func (c *command) Geoadd(key interface{}, longitudeLatitudeMember []LongitudeLatitudeMember) Result {
	r := newAsyncResult()
	if longitudeLatitudeMember == nil {
		r.setErr(newInvalidValueError("longitudeLatitudeMember", nil))
		return r
	}
	c.mu.Lock()
	c.encode("GEOADD", key)
	for _, v := range longitudeLatitudeMember {
		c.encode(v.Longitude, v.Latitude, v.Member)
	}
	c.send(CmdGeoadd, r)
	return r
}

// Geodist - Returns the distance between two members of a geospatial index
// Group: geo
// Since: 3.2.0
// Complexity: O(log(N))
func (c *command) Geodist(key, member1, member2 interface{}, unit *Unit) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("GEODIST", key, member1, member2)
	if unit != nil {
		c.encode(unit)
	}
	c.send(CmdGeodist, r)
	return r
}

// Geohash - Returns members of a geospatial index as standard geohash strings
// Group: geo
// Since: 3.2.0
// Complexity:
// O(log(N)) for each member requested, where N is the number of elements in the
// sorted set.
func (c *command) Geohash(key interface{}, member []interface{}) Result {
	r := newAsyncResult()
	if member == nil {
		r.setErr(newInvalidValueError("member", nil))
		return r
	}
	c.mu.Lock()
	c.encode("GEOHASH", key)
	for _, v := range member {
		c.encode(v)
	}
	c.send(CmdGeohash, r)
	return r
}

// Geopos - Returns longitude and latitude of members of a geospatial index
// Group: geo
// Since: 3.2.0
// Complexity:
// O(log(N)) for each member requested, where N is the number of elements in the
// sorted set.
func (c *command) Geopos(key interface{}, member []interface{}) Result {
	r := newAsyncResult()
	if member == nil {
		r.setErr(newInvalidValueError("member", nil))
		return r
	}
	c.mu.Lock()
	c.encode("GEOPOS", key)
	for _, v := range member {
		c.encode(v)
	}
	c.send(CmdGeopos, r)
	return r
}

// Georadius - Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point
// Group: geo
// Since: 3.2.0
// Complexity:
// O(N+log(M)) where N is the number of elements inside the bounding box of the
// circular area delimited by center and radius and M is the number of items inside the
// index.
func (c *command) Georadius(key interface{}, longitude, latitude, radius float64, unit Unit, withcoord, withdist, withhash bool, count *int64, asc *bool, store, storedist *interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("GEORADIUS", key, longitude, latitude, radius, unit)
	if withcoord {
		c.encode("WITHCOORD")
	}
	if withdist {
		c.encode("WITHDIST")
	}
	if withhash {
		c.encode("WITHHASH")
	}
	if count != nil {
		c.encode("COUNT", count)
	}
	if asc != nil {
		if *asc {
			c.encode("ASC")
		} else {
			c.encode("DESC")
		}
	}
	if store != nil {
		c.encode("STORE", store)
	}
	if storedist != nil {
		c.encode("STOREDIST", storedist)
	}
	c.send(CmdGeoradius, r)
	return r
}

// Georadiusbymember - Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member
// Group: geo
// Since: 3.2.0
// Complexity:
// O(N+log(M)) where N is the number of elements inside the bounding box of the
// circular area delimited by center and radius and M is the number of items inside the
// index.
func (c *command) Georadiusbymember(key, member interface{}, radius float64, unit Unit, withcoord, withdist, withhash bool, count *int64, asc *bool, store, storedist *interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("GEORADIUSBYMEMBER", key, member, radius, unit)
	if withcoord {
		c.encode("WITHCOORD")
	}
	if withdist {
		c.encode("WITHDIST")
	}
	if withhash {
		c.encode("WITHHASH")
	}
	if count != nil {
		c.encode("COUNT", count)
	}
	if asc != nil {
		if *asc {
			c.encode("ASC")
		} else {
			c.encode("DESC")
		}
	}
	if store != nil {
		c.encode("STORE", store)
	}
	if storedist != nil {
		c.encode("STOREDIST", storedist)
	}
	c.send(CmdGeoradiusbymember, r)
	return r
}

// Get - Get the value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Get(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("GET", key)
	c.send(CmdGet, r)
	return r
}

// Getbit - Returns the bit value at offset in the string value stored at key
// Group: string
// Since: 2.2.0
// Complexity: O(1)
func (c *command) Getbit(key interface{}, offset int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("GETBIT", key, offset)
	c.send(CmdGetbit, r)
	return r
}

// Getrange - Get a substring of the string stored at a key
// Group: string
// Since: 2.4.0
// Complexity:
// O(N) where N is the length of the returned string. The complexity is ultimately
// determined by the returned length, but because creating a substring from an existing
// string is very cheap, it can be considered O(1) for small strings.
func (c *command) Getrange(key interface{}, start, end int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("GETRANGE", key, start, end)
	c.send(CmdGetrange, r)
	return r
}

// Getset - Set the string value of a key and return its old value
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Getset(key, value interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("GETSET", key, value)
	c.send(CmdGetset, r)
	return r
}

// Hdel - Delete one or more hash fields
// Group: hash
// Since: 2.0.0
// Complexity: O(N) where N is the number of fields to be removed.
func (c *command) Hdel(key interface{}, field []interface{}) Result {
	r := newAsyncResult()
	if field == nil {
		r.setErr(newInvalidValueError("field", nil))
		return r
	}
	c.mu.Lock()
	c.encode("HDEL", key)
	for _, v := range field {
		c.encode(v)
	}
	c.send(CmdHdel, r)
	return r
}

// Hello - Connection handshake.
// Group: connection
// Since: 6.0.0
func (c *command) Hello(version string, userPassword *UserPassword, clientName *string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HELLO", version)
	if userPassword != nil {
		c.encode("AUTH", userPassword.User, userPassword.Password)
	}
	if clientName != nil {
		c.encode("SETNAME", clientName)
	}
	c.send(CmdHello, r)
	return r
}

// Hexists - Determine if a hash field exists
// Group: hash
// Since: 2.0.0
// Complexity: O(1)
func (c *command) Hexists(key, field interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HEXISTS", key, field)
	c.send(CmdHexists, r)
	return r
}

// Hget - Get the value of a hash field
// Group: hash
// Since: 2.0.0
// Complexity: O(1)
func (c *command) Hget(key, field interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HGET", key, field)
	c.send(CmdHget, r)
	return r
}

// Hgetall - Get all the fields and values in a hash
// Group: hash
// Since: 2.0.0
// Complexity: O(N) where N is the size of the hash.
func (c *command) Hgetall(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HGETALL", key)
	c.send(CmdHgetall, r)
	return r
}

// Hincrby - Increment the integer value of a hash field by the given number
// Group: hash
// Since: 2.0.0
// Complexity: O(1)
func (c *command) Hincrby(key, field interface{}, increment int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HINCRBY", key, field, increment)
	c.send(CmdHincrby, r)
	return r
}

// Hincrbyfloat - Increment the float value of a hash field by the given amount
// Group: hash
// Since: 2.6.0
// Complexity: O(1)
func (c *command) Hincrbyfloat(key, field interface{}, increment float64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HINCRBYFLOAT", key, field, increment)
	c.send(CmdHincrbyfloat, r)
	return r
}

// Hkeys - Get all the fields in a hash
// Group: hash
// Since: 2.0.0
// Complexity: O(N) where N is the size of the hash.
func (c *command) Hkeys(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HKEYS", key)
	c.send(CmdHkeys, r)
	return r
}

// Hlen - Get the number of fields in a hash
// Group: hash
// Since: 2.0.0
// Complexity: O(1)
func (c *command) Hlen(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HLEN", key)
	c.send(CmdHlen, r)
	return r
}

// Hmget - Get the values of all the given hash fields
// Group: hash
// Since: 2.0.0
// Complexity: O(N) where N is the number of fields being requested.
func (c *command) Hmget(key interface{}, field []interface{}) Result {
	r := newAsyncResult()
	if field == nil {
		r.setErr(newInvalidValueError("field", nil))
		return r
	}
	c.mu.Lock()
	c.encode("HMGET", key)
	for _, v := range field {
		c.encode(v)
	}
	c.send(CmdHmget, r)
	return r
}

// Hscan - Incrementally iterate hash fields and associated values
// Group: hash
// Since: 2.8.0
// Complexity:
// O(1) for every call. O(N) for a complete iteration, including enough command
// calls for the cursor to return back to 0. N is the number of elements inside the
// collection..
func (c *command) Hscan(key interface{}, cursor int64, match *string, count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HSCAN", key, cursor)
	if match != nil {
		c.encode("MATCH", match)
	}
	if count != nil {
		c.encode("COUNT", count)
	}
	c.send(CmdHscan, r)
	return r
}

// Hset - Set the string value of a hash field
// Group: hash
// Since: 2.0.0
// Complexity:
// O(1) for each field/value pair added, so O(N) to add N field/value pairs when
// the command is called with multiple field/value pairs.
func (c *command) Hset(key interface{}, fieldValue []FieldValue) Result {
	r := newAsyncResult()
	if fieldValue == nil {
		r.setErr(newInvalidValueError("fieldValue", nil))
		return r
	}
	c.mu.Lock()
	c.encode("HSET", key)
	for _, v := range fieldValue {
		c.encode(v.Field, v.Value)
	}
	c.send(CmdHset, r)
	return r
}

// HsetNx - Set the value of a hash field, only if the field does not exist
// Group: hash
// Since: 2.0.0
// Complexity: O(1)
func (c *command) HsetNx(key, field, value interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HSETNX", key, field, value)
	c.send(CmdHsetNx, r)
	return r
}

// Hstrlen - Get the length of the value of a hash field
// Group: hash
// Since: 3.2.0
// Complexity: O(1)
func (c *command) Hstrlen(key, field interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HSTRLEN", key, field)
	c.send(CmdHstrlen, r)
	return r
}

// Hvals - Get all the values in a hash
// Group: hash
// Since: 2.0.0
// Complexity: O(N) where N is the size of the hash.
func (c *command) Hvals(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("HVALS", key)
	c.send(CmdHvals, r)
	return r
}

// Incr - Increment the integer value of a key by one
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Incr(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("INCR", key)
	c.send(CmdIncr, r)
	return r
}

// Incrby - Increment the integer value of a key by the given amount
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Incrby(key interface{}, increment int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("INCRBY", key, increment)
	c.send(CmdIncrby, r)
	return r
}

// Incrbyfloat - Increment the float value of a key by the given amount
// Group: string
// Since: 2.6.0
// Complexity: O(1)
func (c *command) Incrbyfloat(key interface{}, increment float64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("INCRBYFLOAT", key, increment)
	c.send(CmdIncrbyfloat, r)
	return r
}

// Info - Get information and statistics about the server
// Group: server
// Since: 1.0.0
func (c *command) Info(section *string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("INFO")
	if section != nil {
		c.encode(section)
	}
	c.send(CmdInfo, r)
	return r
}

// Keys - Find all keys matching the given pattern
// Group: generic
// Since: 1.0.0
// Complexity:
// O(N) with N being the number of keys in the database, under the assumption that
// the key names in the database and the given pattern have limited length.
func (c *command) Keys(pattern string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("KEYS", pattern)
	c.send(CmdKeys, r)
	return r
}

// Lastsave - Get the UNIX time stamp of the last successful save to disk
// Group: server
// Since: 1.0.0
func (c *command) Lastsave() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LASTSAVE")
	c.send(CmdLastsave, r)
	return r
}

// LatencyDoctor - Return a human readable latency analysis report.
// Group: server
// Since: 2.8.13
func (c *command) LatencyDoctor() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LATENCY", "DOCTOR")
	c.send(CmdLatencyDoctor, r)
	return r
}

// LatencyGraph - Return a latency graph for the event.
// Group: server
// Since: 2.8.13
func (c *command) LatencyGraph(event string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LATENCY", "GRAPH", event)
	c.send(CmdLatencyGraph, r)
	return r
}

// LatencyHelp - Show helpful text about the different subcommands.
// Group: server
// Since: 2.8.13
func (c *command) LatencyHelp() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LATENCY", "HELP")
	c.send(CmdLatencyHelp, r)
	return r
}

// LatencyHistory - Return timestamp-latency samples for the event.
// Group: server
// Since: 2.8.13
func (c *command) LatencyHistory(event string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LATENCY", "HISTORY", event)
	c.send(CmdLatencyHistory, r)
	return r
}

// LatencyLatest - Return the latest latency samples for all events.
// Group: server
// Since: 2.8.13
func (c *command) LatencyLatest() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LATENCY", "LATEST")
	c.send(CmdLatencyLatest, r)
	return r
}

// LatencyReset - Reset latency data for one or more events.
// Group: server
// Since: 2.8.13
func (c *command) LatencyReset(event *string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LATENCY", "RESET")
	if event != nil {
		c.encode(event)
	}
	c.send(CmdLatencyReset, r)
	return r
}

// Lindex - Get an element from a list by its index
// Group: list
// Since: 1.0.0
// Complexity:
// O(N) where N is the number of elements to traverse to get to the element at
// index. This makes asking for the first or the last element of the list O(1).
func (c *command) Lindex(key interface{}, index int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LINDEX", key, index)
	c.send(CmdLindex, r)
	return r
}

// Linsert - Insert an element before or after another element in a list
// Group: list
// Since: 2.2.0
// Complexity:
// O(N) where N is the number of elements to traverse before seeing the value
// pivot. This means that inserting somewhere on the left end on the list (head) can be
// considered O(1) and inserting somewhere on the right end (tail) is O(N).
func (c *command) Linsert(key interface{}, before bool, pivot, element interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LINSERT", key)
	if before {
		c.encode("BEFORE")
	} else {
		c.encode("AFTER")
	}
	c.encode(pivot, element)
	c.send(CmdLinsert, r)
	return r
}

// Llen - Get the length of a list
// Group: list
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Llen(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LLEN", key)
	c.send(CmdLlen, r)
	return r
}

// Lolwut - Display some computer art and the Redis version
// Group: server
// Since: 5.0.0
func (c *command) Lolwut(version *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LOLWUT")
	if version != nil {
		c.encode("VERSION", version)
	}
	c.send(CmdLolwut, r)
	return r
}

// Lpop - Remove and get the first element in a list
// Group: list
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Lpop(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LPOP", key)
	c.send(CmdLpop, r)
	return r
}

// Lpush - Prepend one or multiple elements to a list
// Group: list
// Since: 1.0.0
// Complexity:
// O(1) for each element added, so O(N) to add N elements when the command is
// called with multiple arguments.
func (c *command) Lpush(key interface{}, element []interface{}) Result {
	r := newAsyncResult()
	if element == nil {
		r.setErr(newInvalidValueError("element", nil))
		return r
	}
	c.mu.Lock()
	c.encode("LPUSH", key)
	for _, v := range element {
		c.encode(v)
	}
	c.send(CmdLpush, r)
	return r
}

// Lpushx - Prepend an element to a list, only if the list exists
// Group: list
// Since: 2.2.0
// Complexity:
// O(1) for each element added, so O(N) to add N elements when the command is
// called with multiple arguments.
func (c *command) Lpushx(key interface{}, element []interface{}) Result {
	r := newAsyncResult()
	if element == nil {
		r.setErr(newInvalidValueError("element", nil))
		return r
	}
	c.mu.Lock()
	c.encode("LPUSHX", key)
	for _, v := range element {
		c.encode(v)
	}
	c.send(CmdLpushx, r)
	return r
}

// Lrange - Get a range of elements from a list
// Group: list
// Since: 1.0.0
// Complexity:
// O(S+N) where S is the distance of start offset from HEAD for small lists, from
// nearest end (HEAD or TAIL) for large lists; and N is the number of elements in the
// specified range.
func (c *command) Lrange(key interface{}, start, stop int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LRANGE", key, start, stop)
	c.send(CmdLrange, r)
	return r
}

// Lrem - Remove elements from a list
// Group: list
// Since: 1.0.0
// Complexity:
// O(N+M) where N is the length of the list and M is the number of elements
// removed.
func (c *command) Lrem(key interface{}, count int64, element interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LREM", key, count, element)
	c.send(CmdLrem, r)
	return r
}

// Lset - Set the value of an element in a list by its index
// Group: list
// Since: 1.0.0
// Complexity:
// O(N) where N is the length of the list. Setting either the first or the last
// element of the list is O(1).
func (c *command) Lset(key interface{}, index int64, element interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LSET", key, index, element)
	c.send(CmdLset, r)
	return r
}

// Ltrim - Trim a list to the specified range
// Group: list
// Since: 1.0.0
// Complexity: O(N) where N is the number of elements to be removed by the operation.
func (c *command) Ltrim(key interface{}, start, stop int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("LTRIM", key, start, stop)
	c.send(CmdLtrim, r)
	return r
}

// MemoryDoctor - Outputs memory problems report
// Group: server
// Since: 4.0.0
func (c *command) MemoryDoctor() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MEMORY", "DOCTOR")
	c.send(CmdMemoryDoctor, r)
	return r
}

// MemoryHelp - Show helpful text about the different subcommands
// Group: server
// Since: 4.0.0
func (c *command) MemoryHelp() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MEMORY", "HELP")
	c.send(CmdMemoryHelp, r)
	return r
}

// MemoryMallocStats - Show allocator internal stats
// Group: server
// Since: 4.0.0
func (c *command) MemoryMallocStats() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MEMORY", "MALLOC-STATS")
	c.send(CmdMemoryMallocStats, r)
	return r
}

// MemoryPurge - Ask the allocator to release memory
// Group: server
// Since: 4.0.0
func (c *command) MemoryPurge() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MEMORY", "PURGE")
	c.send(CmdMemoryPurge, r)
	return r
}

// MemoryStats - Show memory usage details
// Group: server
// Since: 4.0.0
func (c *command) MemoryStats() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MEMORY", "STATS")
	c.send(CmdMemoryStats, r)
	return r
}

// MemoryUsage - Estimate the memory usage of a key
// Group: server
// Since: 4.0.0
// Complexity: O(N) where N is the number of samples.
func (c *command) MemoryUsage(key interface{}, samples *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MEMORY", "USAGE", key)
	if samples != nil {
		c.encode("SAMPLES", samples)
	}
	c.send(CmdMemoryUsage, r)
	return r
}

// Mget - Get the values of all the given keys
// Group: string
// Since: 1.0.0
// Complexity: O(N) where N is the number of keys to retrieve.
func (c *command) Mget(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("MGET")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdMget, r)
	return r
}

// Migrate - Atomically transfer a key from a Redis instance to another one.
// Group: generic
// Since: 2.6.0
// Complexity:
// This command actually executes a DUMP+DEL in the source instance, and a RESTORE
// in the target instance. See the pages of these commands for time complexity. Also
// an O(N) data transfer between the two instances is performed.
func (c *command) Migrate(host, port string, key interface{}, destinationDb, timeout int64, copy, replace bool, auth *string, keys []interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MIGRATE", host, port, key, destinationDb, timeout)
	if copy {
		c.encode("COPY")
	}
	if replace {
		c.encode("REPLACE")
	}
	if auth != nil {
		c.encode("AUTH", auth)
	}
	if keys != nil {
		c.encode("KEYS")
		for _, v := range keys {
			c.encode(v)
		}
	}
	c.send(CmdMigrate, r)
	return r
}

// ModuleList - List all modules loaded by the server
// Group: server
// Since: 4.0.0
// Complexity: O(N) where N is the number of loaded modules.
func (c *command) ModuleList() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MODULE", "LIST")
	c.send(CmdModuleList, r)
	return r
}

// ModuleLoad - Load a module
// Group: server
// Since: 4.0.0
// Complexity: O(1)
func (c *command) ModuleLoad(path string, arg []string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MODULE", "LOAD", path)
	for _, v := range arg {
		c.encode(v)
	}
	c.send(CmdModuleLoad, r)
	return r
}

// ModuleUnload - Unload a module
// Group: server
// Since: 4.0.0
// Complexity: O(1)
func (c *command) ModuleUnload(name string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MODULE", "UNLOAD", name)
	c.send(CmdModuleUnload, r)
	return r
}

// Monitor - Listen for all requests received by the server in real time
// Group: server
// Since: 1.0.0
func (c *command) Monitor() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MONITOR")
	c.send(CmdMonitor, r)
	return r
}

// Move - Move a key to another database
// Group: generic
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Move(key interface{}, db int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MOVE", key, db)
	c.send(CmdMove, r)
	return r
}

// Mset - Set multiple keys to multiple values
// Group: string
// Since: 1.0.1
// Complexity: O(N) where N is the number of keys to set.
func (c *command) Mset(keyValue []KeyValue) Result {
	r := newAsyncResult()
	if keyValue == nil {
		r.setErr(newInvalidValueError("keyValue", nil))
		return r
	}
	c.mu.Lock()
	c.encode("MSET")
	for _, v := range keyValue {
		c.encode(v.Key, v.Value)
	}
	c.send(CmdMset, r)
	return r
}

// MsetNx - Set multiple keys to multiple values, only if none of the keys exist
// Group: string
// Since: 1.0.1
// Complexity: O(N) where N is the number of keys to set.
func (c *command) MsetNx(keyValue []KeyValue) Result {
	r := newAsyncResult()
	if keyValue == nil {
		r.setErr(newInvalidValueError("keyValue", nil))
		return r
	}
	c.mu.Lock()
	c.encode("MSETNX")
	for _, v := range keyValue {
		c.encode(v.Key, v.Value)
	}
	c.send(CmdMsetNx, r)
	return r
}

// Multi - Mark the start of a transaction block
// Group: transactions
// Since: 1.2.0
func (c *command) Multi() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("MULTI")
	c.send(CmdMulti, r)
	return r
}

// ObjectEncoding - Inspect the internals of Redis objects
// Group: generic
// Since: 2.2.3
// Complexity: O(1) for all the currently implemented subcommands.
func (c *command) ObjectEncoding(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("OBJECT", "ENCODING", key)
	c.send(CmdObjectEncoding, r)
	return r
}

// ObjectFreq - Inspect the internals of Redis objects
// Group: generic
// Since: 2.2.3
// Complexity: O(1) for all the currently implemented subcommands.
func (c *command) ObjectFreq(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("OBJECT", "FREQ", key)
	c.send(CmdObjectFreq, r)
	return r
}

// ObjectHelp - Inspect the internals of Redis objects
// Group: generic
// Since: 2.2.3
// Complexity: O(1) for all the currently implemented subcommands.
func (c *command) ObjectHelp() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("OBJECT", "HELP")
	c.send(CmdObjectHelp, r)
	return r
}

// ObjectIdletime - Inspect the internals of Redis objects
// Group: generic
// Since: 2.2.3
// Complexity: O(1) for all the currently implemented subcommands.
func (c *command) ObjectIdletime(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("OBJECT", "IDLETIME", key)
	c.send(CmdObjectIdletime, r)
	return r
}

// ObjectRefcount - Inspect the internals of Redis objects
// Group: generic
// Since: 2.2.3
// Complexity: O(1) for all the currently implemented subcommands.
func (c *command) ObjectRefcount(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("OBJECT", "REFCOUNT", key)
	c.send(CmdObjectRefcount, r)
	return r
}

// PTTL - Get the time to live for a key in milliseconds
// Group: generic
// Since: 2.6.0
// Complexity: O(1)
func (c *command) PTTL(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("PTTL", key)
	c.send(CmdPTTL, r)
	return r
}

// Persist - Remove the expiration from a key
// Group: generic
// Since: 2.2.0
// Complexity: O(1)
func (c *command) Persist(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("PERSIST", key)
	c.send(CmdPersist, r)
	return r
}

// Pexpire - Set a key's time to live in milliseconds
// Group: generic
// Since: 2.6.0
// Complexity: O(1)
func (c *command) Pexpire(key interface{}, milliseconds int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("PEXPIRE", key, milliseconds)
	c.send(CmdPexpire, r)
	return r
}

// Pexpireat - Set the expiration for a key as a UNIX timestamp specified in milliseconds
// Group: generic
// Since: 2.6.0
// Complexity: O(1)
func (c *command) Pexpireat(key interface{}, millisecondsTimestamp int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("PEXPIREAT", key, millisecondsTimestamp)
	c.send(CmdPexpireat, r)
	return r
}

// Pfadd - Adds the specified elements to the specified HyperLogLog.
// Group: hyperloglog
// Since: 2.8.9
// Complexity: O(1) to add every element.
func (c *command) Pfadd(key interface{}, element []interface{}) Result {
	r := newAsyncResult()
	if element == nil {
		r.setErr(newInvalidValueError("element", nil))
		return r
	}
	c.mu.Lock()
	c.encode("PFADD", key)
	for _, v := range element {
		c.encode(v)
	}
	c.send(CmdPfadd, r)
	return r
}

// Pfcount - Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).
// Group: hyperloglog
// Since: 2.8.9
// Complexity:
// O(1) with a very small average constant time when called with a single key.
// O(N) with N being the number of keys, and much bigger constant times, when called
// with multiple keys.
func (c *command) Pfcount(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("PFCOUNT")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdPfcount, r)
	return r
}

// Pfmerge - Merge N different HyperLogLogs into a single one.
// Group: hyperloglog
// Since: 2.8.9
// Complexity: O(N) to merge N HyperLogLogs, but with high constant times.
func (c *command) Pfmerge(destkey interface{}, sourcekey []interface{}) Result {
	r := newAsyncResult()
	if sourcekey == nil {
		r.setErr(newInvalidValueError("sourcekey", nil))
		return r
	}
	c.mu.Lock()
	c.encode("PFMERGE", destkey)
	for _, v := range sourcekey {
		c.encode(v)
	}
	c.send(CmdPfmerge, r)
	return r
}

// Ping - Ping the server
// Group: connection
// Since: 1.0.0
func (c *command) Ping(message *string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("PING")
	if message != nil {
		c.encode(message)
	}
	c.send(CmdPing, r)
	return r
}

// Psubscribe - Listen for messages published to channels matching the given patterns
// Group: pubsub
// Since: 2.0.0
// Complexity: O(N) where N is the number of patterns the client is already subscribed to.
func (c *command) Psubscribe(pattern []string, cb MsgCallback) Result {
	r := newAsyncSubscribeResult()
	if pattern == nil {
		r.setErr(newInvalidValueError("pattern", nil))
		return r
	}
	r.channel = pattern[:]
	r.cb = cb
	c.mu.Lock()
	c.encode("PSUBSCRIBE")
	for _, v := range pattern {
		c.encode(v)
	}
	c.send(CmdPsubscribe, r)
	return r
}

// Psync - Internal command used for replication
// Group: server
// Since: 2.8.0
func (c *command) Psync(replicationid, offset int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("PSYNC", replicationid, offset)
	c.send(CmdPsync, r)
	return r
}

// Publish - Post a message to a channel
// Group: pubsub
// Since: 2.0.0
// Complexity:
// O(N+M) where N is the number of clients subscribed to the receiving channel and
// M is the total number of subscribed patterns (by any client).
func (c *command) Publish(channel, message string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("PUBLISH", channel, message)
	c.send(CmdPublish, r)
	return r
}

// PubsubChannels - Inspect the state of the Pub/Sub subsystem
// Group: pubsub
// Since: 2.8.0
// Complexity:
// O(N) for the CHANNELS subcommand, where N is the number of active channels, and
// assuming constant time pattern matching (relatively short channels and patterns). O(N)
// for the NUMSUB subcommand, where N is the number of requested channels. O(1) for
// the NUMPAT subcommand.
func (c *command) PubsubChannels(pattern *string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("PUBSUB", "CHANNELS")
	if pattern != nil {
		c.encode(pattern)
	}
	c.send(CmdPubsubChannels, r)
	return r
}

// PubsubNumpat - Inspect the state of the Pub/Sub subsystem
// Group: pubsub
// Since: 2.8.0
// Complexity:
// O(N) for the CHANNELS subcommand, where N is the number of active channels, and
// assuming constant time pattern matching (relatively short channels and patterns). O(N)
// for the NUMSUB subcommand, where N is the number of requested channels. O(1) for
// the NUMPAT subcommand.
func (c *command) PubsubNumpat() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("PUBSUB", "NUMPAT")
	c.send(CmdPubsubNumpat, r)
	return r
}

// PubsubNumsub - Inspect the state of the Pub/Sub subsystem
// Group: pubsub
// Since: 2.8.0
// Complexity:
// O(N) for the CHANNELS subcommand, where N is the number of active channels, and
// assuming constant time pattern matching (relatively short channels and patterns). O(N)
// for the NUMSUB subcommand, where N is the number of requested channels. O(1) for
// the NUMPAT subcommand.
func (c *command) PubsubNumsub(channel []string) Result {
	r := newAsyncResult()
	if channel == nil {
		r.setErr(newInvalidValueError("channel", nil))
		return r
	}
	c.mu.Lock()
	c.encode("PUBSUB", "NUMSUB")
	for _, v := range channel {
		c.encode(v)
	}
	c.send(CmdPubsubNumsub, r)
	return r
}

// Punsubscribe - Stop listening for messages posted to channels matching the given patterns
// Group: pubsub
// Since: 2.0.0
// Complexity:
// O(N+M) where N is the number of patterns the client is already subscribed and M
// is the number of total patterns subscribed in the system (by any client).
func (c *command) Punsubscribe(pattern []string) Result {
	r := newAsyncUnsubscribeResult()
	r.channel = pattern[:]
	c.mu.Lock()
	c.encode("PUNSUBSCRIBE")
	for _, v := range pattern {
		c.encode(v)
	}
	c.send(CmdPunsubscribe, r)
	return r
}

// Quit - Close the connection
// Group: connection
// Since: 1.0.0
func (c *command) Quit() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("QUIT")
	c.send(CmdQuit, r)
	return r
}

// Randomkey - Return a random key from the keyspace
// Group: generic
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Randomkey() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("RANDOMKEY")
	c.send(CmdRandomkey, r)
	return r
}

// Readonly - Enables read queries for a connection to a cluster replica node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) Readonly() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("READONLY")
	c.send(CmdReadonly, r)
	return r
}

// Readwrite - Disables read queries for a connection to a cluster replica node
// Group: cluster
// Since: 3.0.0
// Complexity: O(1)
func (c *command) Readwrite() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("READWRITE")
	c.send(CmdReadwrite, r)
	return r
}

// Rename - Rename a key
// Group: generic
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Rename(key, newkey interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("RENAME", key, newkey)
	c.send(CmdRename, r)
	return r
}

// RenameNx - Rename a key, only if the new key does not exist
// Group: generic
// Since: 1.0.0
// Complexity: O(1)
func (c *command) RenameNx(key, newkey interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("RENAMENX", key, newkey)
	c.send(CmdRenameNx, r)
	return r
}

// Replicaof - Make the server a replica of another instance, or promote it as master.
// Group: server
// Since: 5.0.0
func (c *command) Replicaof(host, port string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("REPLICAOF", host, port)
	c.send(CmdReplicaof, r)
	return r
}

// Restore - Create a key using the provided serialized value, previously obtained using DUMP.
// Group: generic
// Since: 2.6.0
// Complexity:
// O(1) to create the new key and additional O(N*M) to reconstruct the serialized
// value, where N is the number of Redis objects composing the value and M their average
// size. For small string values the time complexity is thus O(1)+O(1*M) where M is
// small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N))
// because inserting values into sorted sets is O(log(N)).
func (c *command) Restore(key interface{}, ttl int64, serializedValue string, replace, absttl bool, idletime, freq *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("RESTORE", key, ttl, serializedValue)
	if replace {
		c.encode("REPLACE")
	}
	if absttl {
		c.encode("ABSTTL")
	}
	if idletime != nil {
		c.encode("IDLETIME", idletime)
	}
	if freq != nil {
		c.encode("FREQ", freq)
	}
	c.send(CmdRestore, r)
	return r
}

// Role - Return the role of the instance in the context of replication
// Group: server
// Since: 2.8.12
func (c *command) Role() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ROLE")
	c.send(CmdRole, r)
	return r
}

// Rpop - Remove and get the last element in a list
// Group: list
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Rpop(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("RPOP", key)
	c.send(CmdRpop, r)
	return r
}

// Rpoplpush - Remove the last element in a list, prepend it to another list and return it
// Group: list
// Since: 1.2.0
// Complexity: O(1)
func (c *command) Rpoplpush(source, destination interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("RPOPLPUSH", source, destination)
	c.send(CmdRpoplpush, r)
	return r
}

// Rpush - Append one or multiple elements to a list
// Group: list
// Since: 1.0.0
// Complexity:
// O(1) for each element added, so O(N) to add N elements when the command is
// called with multiple arguments.
func (c *command) Rpush(key interface{}, element []interface{}) Result {
	r := newAsyncResult()
	if element == nil {
		r.setErr(newInvalidValueError("element", nil))
		return r
	}
	c.mu.Lock()
	c.encode("RPUSH", key)
	for _, v := range element {
		c.encode(v)
	}
	c.send(CmdRpush, r)
	return r
}

// Rpushx - Append an element to a list, only if the list exists
// Group: list
// Since: 2.2.0
// Complexity:
// O(1) for each element added, so O(N) to add N elements when the command is
// called with multiple arguments.
func (c *command) Rpushx(key interface{}, element []interface{}) Result {
	r := newAsyncResult()
	if element == nil {
		r.setErr(newInvalidValueError("element", nil))
		return r
	}
	c.mu.Lock()
	c.encode("RPUSHX", key)
	for _, v := range element {
		c.encode(v)
	}
	c.send(CmdRpushx, r)
	return r
}

// Sadd - Add one or more members to a set
// Group: set
// Since: 1.0.0
// Complexity:
// O(1) for each element added, so O(N) to add N elements when the command is
// called with multiple arguments.
func (c *command) Sadd(key interface{}, member []interface{}) Result {
	r := newAsyncResult()
	if member == nil {
		r.setErr(newInvalidValueError("member", nil))
		return r
	}
	c.mu.Lock()
	c.encode("SADD", key)
	for _, v := range member {
		c.encode(v)
	}
	c.send(CmdSadd, r)
	return r
}

// Save - Synchronously save the dataset to disk
// Group: server
// Since: 1.0.0
func (c *command) Save() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SAVE")
	c.send(CmdSave, r)
	return r
}

// Scan - Incrementally iterate the keys space
// Group: generic
// Since: 2.8.0
// Complexity:
// O(1) for every call. O(N) for a complete iteration, including enough command
// calls for the cursor to return back to 0. N is the number of elements inside the
// collection.
func (c *command) Scan(cursor int64, match *string, count *int64, typ *string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SCAN", cursor)
	if match != nil {
		c.encode("MATCH", match)
	}
	if count != nil {
		c.encode("COUNT", count)
	}
	if typ != nil {
		c.encode("TYPE", typ)
	}
	c.send(CmdScan, r)
	return r
}

// Scard - Get the number of members in a set
// Group: set
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Scard(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SCARD", key)
	c.send(CmdScard, r)
	return r
}

// ScriptDebug - Set the debug mode for executed scripts.
// Group: scripting
// Since: 3.2.0
// Complexity: O(1)
func (c *command) ScriptDebug(mode Mode) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SCRIPT", "DEBUG", mode)
	c.send(CmdScriptDebug, r)
	return r
}

// ScriptExists - Check existence of scripts in the script cache.
// Group: scripting
// Since: 2.6.0
// Complexity:
// O(N) with N being the number of scripts to check (so checking a single script
// is an O(1) operation).
func (c *command) ScriptExists(sha1 []string) Result {
	r := newAsyncResult()
	if sha1 == nil {
		r.setErr(newInvalidValueError("sha1", nil))
		return r
	}
	c.mu.Lock()
	c.encode("SCRIPT", "EXISTS")
	for _, v := range sha1 {
		c.encode(v)
	}
	c.send(CmdScriptExists, r)
	return r
}

// ScriptFlush - Remove all the scripts from the script cache.
// Group: scripting
// Since: 2.6.0
// Complexity: O(N) with N being the number of scripts in cache
func (c *command) ScriptFlush() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SCRIPT", "FLUSH")
	c.send(CmdScriptFlush, r)
	return r
}

// ScriptKill - Kill the script currently in execution.
// Group: scripting
// Since: 2.6.0
// Complexity: O(1)
func (c *command) ScriptKill() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SCRIPT", "KILL")
	c.send(CmdScriptKill, r)
	return r
}

// ScriptLoad - Load the specified Lua script into the script cache.
// Group: scripting
// Since: 2.6.0
// Complexity: O(N) with N being the length in bytes of the script body.
func (c *command) ScriptLoad(script string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SCRIPT", "LOAD", script)
	c.send(CmdScriptLoad, r)
	return r
}

// Sdiff - Subtract multiple sets
// Group: set
// Since: 1.0.0
// Complexity: O(N) where N is the total number of elements in all given sets.
func (c *command) Sdiff(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("SDIFF")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdSdiff, r)
	return r
}

// Sdiffstore - Subtract multiple sets and store the resulting set in a key
// Group: set
// Since: 1.0.0
// Complexity: O(N) where N is the total number of elements in all given sets.
func (c *command) Sdiffstore(destination interface{}, key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("SDIFFSTORE", destination)
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdSdiffstore, r)
	return r
}

// Select - Change the selected database for the current connection
// Group: connection
// Since: 1.0.0
func (c *command) Select(index int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SELECT", index)
	c.send(CmdSelect, r)
	return r
}

// Set - Set the string value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Set(key, value interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SET", key, value)
	c.send(CmdSet, r)
	return r
}

// SetEx - Set the string value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) SetEx(key, value interface{}, seconds int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SET", key, value, "EX", seconds)
	c.send(CmdSetEx, r)
	return r
}

// SetExNx - Set the string value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) SetExNx(key, value interface{}, seconds int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SET", key, value, "EX", seconds, "NX")
	c.send(CmdSetExNx, r)
	return r
}

// SetExXx - Set the string value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) SetExXx(key, value interface{}, seconds int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SET", key, value, "EX", seconds, "XX")
	c.send(CmdSetExXx, r)
	return r
}

// SetNx - Set the string value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) SetNx(key, value interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SET", key, value, "NX")
	c.send(CmdSetNx, r)
	return r
}

// SetPx - Set the string value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) SetPx(key, value interface{}, milliseconds int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SET", key, value, "PX", milliseconds)
	c.send(CmdSetPx, r)
	return r
}

// SetPxNx - Set the string value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) SetPxNx(key, value interface{}, milliseconds int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SET", key, value, "PX", milliseconds, "NX")
	c.send(CmdSetPxNx, r)
	return r
}

// SetPxXx - Set the string value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) SetPxXx(key, value interface{}, milliseconds int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SET", key, value, "PX", milliseconds, "XX")
	c.send(CmdSetPxXx, r)
	return r
}

// SetXx - Set the string value of a key
// Group: string
// Since: 1.0.0
// Complexity: O(1)
func (c *command) SetXx(key, value interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SET", key, value, "XX")
	c.send(CmdSetXx, r)
	return r
}

// Setbit - Sets or clears the bit at offset in the string value stored at key
// Group: string
// Since: 2.2.0
// Complexity: O(1)
func (c *command) Setbit(key interface{}, offset, value int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SETBIT", key, offset, value)
	c.send(CmdSetbit, r)
	return r
}

// Setrange - Overwrite part of a string at key starting at the specified offset
// Group: string
// Since: 2.2.0
// Complexity:
// O(1), not counting the time taken to copy the new string in place. Usually,
// this string is very small so the amortized complexity is O(1). Otherwise, complexity
// is O(M) with M being the length of the value argument.
func (c *command) Setrange(key interface{}, offset int64, value interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SETRANGE", key, offset, value)
	c.send(CmdSetrange, r)
	return r
}

// Shutdown - Synchronously save the dataset to disk and then shut down the server
// Group: server
// Since: 1.0.0
func (c *command) Shutdown(nosave *bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SHUTDOWN")
	if nosave != nil {
		if *nosave {
			c.encode("NOSAVE")
		} else {
			c.encode("SAVE")
		}
	}
	c.send(CmdShutdown, r)
	return r
}

// Sinter - Intersect multiple sets
// Group: set
// Since: 1.0.0
// Complexity:
// O(N*M) worst case where N is the cardinality of the smallest set and M is the
// number of sets.
func (c *command) Sinter(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("SINTER")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdSinter, r)
	return r
}

// Sinterstore - Intersect multiple sets and store the resulting set in a key
// Group: set
// Since: 1.0.0
// Complexity:
// O(N*M) worst case where N is the cardinality of the smallest set and M is the
// number of sets.
func (c *command) Sinterstore(destination interface{}, key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("SINTERSTORE", destination)
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdSinterstore, r)
	return r
}

// Sismember - Determine if a given value is a member of a set
// Group: set
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Sismember(key, member interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SISMEMBER", key, member)
	c.send(CmdSismember, r)
	return r
}

// SlowlogGet - Manages the Redis slow queries log
// Group: server
// Since: 2.2.12
func (c *command) SlowlogGet(count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SLOWLOG", "GET")
	if count != nil {
		c.encode(count)
	}
	c.send(CmdSlowlogGet, r)
	return r
}

// SlowlogLen - Manages the Redis slow queries log
// Group: server
// Since: 2.2.12
func (c *command) SlowlogLen() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SLOWLOG", "LEN")
	c.send(CmdSlowlogLen, r)
	return r
}

// SlowlogReset - Manages the Redis slow queries log
// Group: server
// Since: 2.2.12
func (c *command) SlowlogReset() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SLOWLOG", "RESET")
	c.send(CmdSlowlogReset, r)
	return r
}

// Smembers - Get all the members in a set
// Group: set
// Since: 1.0.0
// Complexity: O(N) where N is the set cardinality.
func (c *command) Smembers(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SMEMBERS", key)
	c.send(CmdSmembers, r)
	return r
}

// Smove - Move a member from one set to another
// Group: set
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Smove(source, destination, member interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SMOVE", source, destination, member)
	c.send(CmdSmove, r)
	return r
}

// Sort - Sort the elements in a list, set or sorted set
// Group: generic
// Since: 1.0.0
// Complexity:
// O(N+M*log(M)) where N is the number of elements in the list or set to sort, and
// M the number of returned elements. When the elements are not sorted, complexity
// is currently O(N) as there is a copy step that will be avoided in next releases.
func (c *command) Sort(key interface{}, by *string, limit *OffsetCount, get []string, asc *bool, sorting bool, store *interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SORT", key)
	if by != nil {
		c.encode("BY", by)
	}
	if limit != nil {
		c.encode("LIMIT", limit.Offset, limit.Count)
	}
	if get != nil {
		c.encode("GET")
		for _, v := range get {
			c.encode(v)
		}
	}
	if asc != nil {
		if *asc {
			c.encode("ASC")
		} else {
			c.encode("DESC")
		}
	}
	if sorting {
		c.encode("ALPHA")
	}
	if store != nil {
		c.encode("STORE", store)
	}
	c.send(CmdSort, r)
	return r
}

// Spop - Remove and return one or multiple random members from a set
// Group: set
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Spop(key interface{}, count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SPOP", key)
	if count != nil {
		c.encode(count)
	}
	c.send(CmdSpop, r)
	return r
}

// Srandmember - Get one or multiple random members from a set
// Group: set
// Since: 1.0.0
// Complexity:
// Without the count argument O(1), otherwise O(N) where N is the absolute value
// of the passed count.
func (c *command) Srandmember(key interface{}, count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SRANDMEMBER", key)
	if count != nil {
		c.encode(count)
	}
	c.send(CmdSrandmember, r)
	return r
}

// Srem - Remove one or more members from a set
// Group: set
// Since: 1.0.0
// Complexity: O(N) where N is the number of members to be removed.
func (c *command) Srem(key interface{}, member []interface{}) Result {
	r := newAsyncResult()
	if member == nil {
		r.setErr(newInvalidValueError("member", nil))
		return r
	}
	c.mu.Lock()
	c.encode("SREM", key)
	for _, v := range member {
		c.encode(v)
	}
	c.send(CmdSrem, r)
	return r
}

// Sscan - Incrementally iterate Set elements
// Group: set
// Since: 2.8.0
// Complexity:
// O(1) for every call. O(N) for a complete iteration, including enough command
// calls for the cursor to return back to 0. N is the number of elements inside the
// collection..
func (c *command) Sscan(key interface{}, cursor int64, match *string, count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SSCAN", key, cursor)
	if match != nil {
		c.encode("MATCH", match)
	}
	if count != nil {
		c.encode("COUNT", count)
	}
	c.send(CmdSscan, r)
	return r
}

// Strlen - Get the length of the value stored in a key
// Group: string
// Since: 2.2.0
// Complexity: O(1)
func (c *command) Strlen(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("STRLEN", key)
	c.send(CmdStrlen, r)
	return r
}

// Subscribe - Listen for messages published to the given channels
// Group: pubsub
// Since: 2.0.0
// Complexity: O(N) where N is the number of channels to subscribe to.
func (c *command) Subscribe(channel []string, cb MsgCallback) Result {
	r := newAsyncSubscribeResult()
	if channel == nil {
		r.setErr(newInvalidValueError("channel", nil))
		return r
	}
	r.channel = channel[:]
	r.cb = cb
	c.mu.Lock()
	c.encode("SUBSCRIBE")
	for _, v := range channel {
		c.encode(v)
	}
	c.send(CmdSubscribe, r)
	return r
}

// Sunion - Add multiple sets
// Group: set
// Since: 1.0.0
// Complexity: O(N) where N is the total number of elements in all given sets.
func (c *command) Sunion(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("SUNION")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdSunion, r)
	return r
}

// Sunionstore - Add multiple sets and store the resulting set in a key
// Group: set
// Since: 1.0.0
// Complexity: O(N) where N is the total number of elements in all given sets.
func (c *command) Sunionstore(destination interface{}, key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("SUNIONSTORE", destination)
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdSunionstore, r)
	return r
}

// Swapdb - Swaps two Redis databases
// Group: connection
// Since: 4.0.0
func (c *command) Swapdb(index1, index2 int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("SWAPDB", index1, index2)
	c.send(CmdSwapdb, r)
	return r
}

// TTL - Get the time to live for a key
// Group: generic
// Since: 1.0.0
// Complexity: O(1)
func (c *command) TTL(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("TTL", key)
	c.send(CmdTTL, r)
	return r
}

// Time - Return the current server time
// Group: server
// Since: 2.6.0
// Complexity: O(1)
func (c *command) Time() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("TIME")
	c.send(CmdTime, r)
	return r
}

// Touch - Alters the last access time of a key(s). Returns the number of existing keys specified.
// Group: generic
// Since: 3.2.1
// Complexity: O(N) where N is the number of keys that will be touched.
func (c *command) Touch(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("TOUCH")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdTouch, r)
	return r
}

// Type - Determine the type stored at key
// Group: generic
// Since: 1.0.0
// Complexity: O(1)
func (c *command) Type(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("TYPE", key)
	c.send(CmdType, r)
	return r
}

// Unlink - Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking.
// Group: generic
// Since: 4.0.0
// Complexity:
// O(1) for each key removed regardless of its size. Then the command does O(N)
// work in a different thread in order to reclaim memory, where N is the number of
// allocations the deleted objects where composed of.
func (c *command) Unlink(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("UNLINK")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdUnlink, r)
	return r
}

// Unsubscribe - Stop listening for messages posted to the given channels
// Group: pubsub
// Since: 2.0.0
// Complexity: O(N) where N is the number of clients already subscribed to a channel.
func (c *command) Unsubscribe(channel []string) Result {
	r := newAsyncUnsubscribeResult()
	r.channel = channel[:]
	c.mu.Lock()
	c.encode("UNSUBSCRIBE")
	for _, v := range channel {
		c.encode(v)
	}
	c.send(CmdUnsubscribe, r)
	return r
}

// Unwatch - Forget about all watched keys
// Group: transactions
// Since: 2.2.0
// Complexity: O(1)
func (c *command) Unwatch() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("UNWATCH")
	c.send(CmdUnwatch, r)
	return r
}

// Wait - Wait for the synchronous replication of all the write commands sent in the context of the current connection
// Group: generic
// Since: 3.0.0
// Complexity: O(1)
func (c *command) Wait(numreplicas, timeout int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("WAIT", numreplicas, timeout)
	c.send(CmdWait, r)
	return r
}

// Watch - Watch the given keys to determine execution of the MULTI/EXEC block
// Group: transactions
// Since: 2.2.0
// Complexity: O(1) for every key.
func (c *command) Watch(key []interface{}) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("WATCH")
	for _, v := range key {
		c.encode(v)
	}
	c.send(CmdWatch, r)
	return r
}

// Xack - Marks a pending message as correctly processed, effectively removing it from the pending entries list of the consumer group. Return value of the command is the number of messages successfully acknowledged, that is, the IDs we were actually able to resolve in the PEL.
// Group: stream
// Since: 5.0.0
// Complexity: O(1) for each message ID processed.
func (c *command) Xack(key interface{}, group string, id []string) Result {
	r := newAsyncResult()
	if id == nil {
		r.setErr(newInvalidValueError("id", nil))
		return r
	}
	c.mu.Lock()
	c.encode("XACK", key, group)
	for _, v := range id {
		c.encode(v)
	}
	c.send(CmdXack, r)
	return r
}

// Xadd - Appends a new entry to a stream
// Group: stream
// Since: 5.0.0
// Complexity: O(1)
func (c *command) Xadd(key interface{}, id string, fieldValue []FieldValue) Result {
	r := newAsyncResult()
	if fieldValue == nil {
		r.setErr(newInvalidValueError("fieldValue", nil))
		return r
	}
	c.mu.Lock()
	c.encode("XADD", key, id)
	for _, v := range fieldValue {
		c.encode(v.Field, v.Value)
	}
	c.send(CmdXadd, r)
	return r
}

// Xclaim - Changes (or acquires) ownership of a message in a consumer group, as if the message was delivered to the specified consumer.
// Group: stream
// Since: 5.0.0
// Complexity: O(log N) with N being the number of messages in the PEL of the consumer group.
func (c *command) Xclaim(key interface{}, group, consumer, minIdleTime string, id []string, idle, time, retrycount *int64, force, justid bool) Result {
	r := newAsyncResult()
	if id == nil {
		r.setErr(newInvalidValueError("id", nil))
		return r
	}
	c.mu.Lock()
	c.encode("XCLAIM", key, group, consumer, minIdleTime)
	for _, v := range id {
		c.encode(v)
	}
	if idle != nil {
		c.encode("IDLE", idle)
	}
	if time != nil {
		c.encode("TIME", time)
	}
	if retrycount != nil {
		c.encode("RETRYCOUNT", retrycount)
	}
	if force {
		c.encode("FORCE")
	}
	if justid {
		c.encode("JUSTID")
	}
	c.send(CmdXclaim, r)
	return r
}

// Xdel - Removes the specified entries from the stream. Returns the number of items actually deleted, that may be different from the number of IDs passed in case certain IDs do not exist.
// Group: stream
// Since: 5.0.0
// Complexity:
// O(1) for each single item to delete in the stream, regardless of the stream
// size.
func (c *command) Xdel(key interface{}, id []string) Result {
	r := newAsyncResult()
	if id == nil {
		r.setErr(newInvalidValueError("id", nil))
		return r
	}
	c.mu.Lock()
	c.encode("XDEL", key)
	for _, v := range id {
		c.encode(v)
	}
	c.send(CmdXdel, r)
	return r
}

// XgroupCreate - Create, destroy, and manage consumer groups.
// Group: stream
// Since: 5.0.0
// Complexity:
// O(1) for all the subcommands, with the exception of the DESTROY subcommand
// which takes an additional O(M) time in order to delete the M entries inside the
// consumer group pending entries list (PEL).
func (c *command) XgroupCreate(key interface{}, groupname, id string, mkstream bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XGROUP", "CREATE", key, groupname, id)
	if mkstream {
		c.encode("MKSTREAM")
	}
	c.send(CmdXgroupCreate, r)
	return r
}

// XgroupDelconsumer - Create, destroy, and manage consumer groups.
// Group: stream
// Since: 5.0.0
// Complexity:
// O(1) for all the subcommands, with the exception of the DESTROY subcommand
// which takes an additional O(M) time in order to delete the M entries inside the
// consumer group pending entries list (PEL).
func (c *command) XgroupDelconsumer(key interface{}, groupname, consumername string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XGROUP", "DELCONSUMER", key, groupname, consumername)
	c.send(CmdXgroupDelconsumer, r)
	return r
}

// XgroupDestroy - Create, destroy, and manage consumer groups.
// Group: stream
// Since: 5.0.0
// Complexity:
// O(1) for all the subcommands, with the exception of the DESTROY subcommand
// which takes an additional O(M) time in order to delete the M entries inside the
// consumer group pending entries list (PEL).
func (c *command) XgroupDestroy(key interface{}, groupname string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XGROUP", "DESTROY", key, groupname)
	c.send(CmdXgroupDestroy, r)
	return r
}

// XgroupHelp - Create, destroy, and manage consumer groups.
// Group: stream
// Since: 5.0.0
// Complexity:
// O(1) for all the subcommands, with the exception of the DESTROY subcommand
// which takes an additional O(M) time in order to delete the M entries inside the
// consumer group pending entries list (PEL).
func (c *command) XgroupHelp() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XGROUP", "HELP")
	c.send(CmdXgroupHelp, r)
	return r
}

// XgroupSetid - Create, destroy, and manage consumer groups.
// Group: stream
// Since: 5.0.0
// Complexity:
// O(1) for all the subcommands, with the exception of the DESTROY subcommand
// which takes an additional O(M) time in order to delete the M entries inside the
// consumer group pending entries list (PEL).
func (c *command) XgroupSetid(key interface{}, groupname, id string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XGROUP", "SETID", key, groupname, id)
	c.send(CmdXgroupSetid, r)
	return r
}

// XinfoConsumers - Get information on streams and consumer groups
// Group: stream
// Since: 5.0.0
// Complexity:
// O(N) with N being the number of returned items for the subcommands CONSUMERS
// and GROUPS. The STREAM subcommand is O(log N) with N being the number of items in
// the stream.
func (c *command) XinfoConsumers(key interface{}, groupname string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XINFO", "CONSUMERS", key, groupname)
	c.send(CmdXinfoConsumers, r)
	return r
}

// XinfoGroups - Get information on streams and consumer groups
// Group: stream
// Since: 5.0.0
// Complexity:
// O(N) with N being the number of returned items for the subcommands CONSUMERS
// and GROUPS. The STREAM subcommand is O(log N) with N being the number of items in
// the stream.
func (c *command) XinfoGroups(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XINFO", "GROUPS", key)
	c.send(CmdXinfoGroups, r)
	return r
}

// XinfoHelp - Get information on streams and consumer groups
// Group: stream
// Since: 5.0.0
// Complexity:
// O(N) with N being the number of returned items for the subcommands CONSUMERS
// and GROUPS. The STREAM subcommand is O(log N) with N being the number of items in
// the stream.
func (c *command) XinfoHelp() Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XINFO", "HELP")
	c.send(CmdXinfoHelp, r)
	return r
}

// XinfoStream - Get information on streams and consumer groups
// Group: stream
// Since: 5.0.0
// Complexity:
// O(N) with N being the number of returned items for the subcommands CONSUMERS
// and GROUPS. The STREAM subcommand is O(log N) with N being the number of items in
// the stream.
func (c *command) XinfoStream(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XINFO", "STREAM", key)
	c.send(CmdXinfoStream, r)
	return r
}

// Xlen - Return the number of entires in a stream
// Group: stream
// Since: 5.0.0
// Complexity: O(1)
func (c *command) Xlen(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XLEN", key)
	c.send(CmdXlen, r)
	return r
}

// Xpending - Return information and entries from a stream consumer group pending entries list, that are messages fetched but never acknowledged.
// Group: stream
// Since: 5.0.0
// Complexity:
// O(N) with N being the number of elements returned, so asking for a small fixed
// number of entries per call is O(1). When the command returns just the summary it runs
// in O(1) time assuming the list of consumers is small, otherwise there is
// additional O(N) time needed to iterate every consumer.
func (c *command) Xpending(key interface{}, group string, startEndCount *StartEndCount, consumer *string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XPENDING", key, group)
	if startEndCount != nil {
		c.encode(startEndCount.Start, startEndCount.End, startEndCount.Count)
	}
	if consumer != nil {
		c.encode(consumer)
	}
	c.send(CmdXpending, r)
	return r
}

// Xrange - Return a range of elements in a stream, with IDs matching the specified IDs interval
// Group: stream
// Since: 5.0.0
// Complexity:
// O(N) with N being the number of elements being returned. If N is constant (e.g.
// always asking for the first 10 elements with COUNT), you can consider it O(1).
func (c *command) Xrange(key interface{}, start, end string, count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XRANGE", key, start, end)
	if count != nil {
		c.encode("COUNT", count)
	}
	c.send(CmdXrange, r)
	return r
}

// Xread - Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block.
// Group: stream
// Since: 5.0.0
// Complexity:
// For each stream mentioned: O(N) with N being the number of elements being
// returned, it means that XREAD-ing with a fixed COUNT is O(1). Note that when the BLOCK
// option is used, XADD will pay O(M) time in order to serve the M clients blocked on the
// stream getting new data.
func (c *command) Xread(count, block *int64, key []interface{}, id []string) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	if id == nil {
		r.setErr(newInvalidValueError("id", nil))
		return r
	}
	c.mu.Lock()
	c.encode("XREAD")
	if count != nil {
		c.encode("COUNT", count)
	}
	if block != nil {
		c.encode("BLOCK", block)
	}
	c.encode("STREAMS")
	for _, v := range key {
		c.encode(v)
	}
	for _, v := range id {
		c.encode(v)
	}
	c.send(CmdXread, r)
	return r
}

// Xreadgroup - Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block.
// Group: stream
// Since: 5.0.0
// Complexity:
// For each stream mentioned: O(M) with M being the number of elements returned.
// If M is constant (e.g. always asking for the first 10 elements with COUNT), you
// can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the
// O(N) time in order to serve the N clients blocked on the stream getting new data.
func (c *command) Xreadgroup(group GroupConsumer, count, block *int64, noack bool, key []interface{}, id []string) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	if id == nil {
		r.setErr(newInvalidValueError("id", nil))
		return r
	}
	c.mu.Lock()
	c.encode("XREADGROUP", "GROUP", group.Group, group.Consumer)
	if count != nil {
		c.encode("COUNT", count)
	}
	if block != nil {
		c.encode("BLOCK", block)
	}
	if noack {
		c.encode("NOACK")
	}
	c.encode("STREAMS")
	for _, v := range key {
		c.encode(v)
	}
	for _, v := range id {
		c.encode(v)
	}
	c.send(CmdXreadgroup, r)
	return r
}

// Xrevrange - Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE
// Group: stream
// Since: 5.0.0
// Complexity:
// O(N) with N being the number of elements returned. If N is constant (e.g.
// always asking for the first 10 elements with COUNT), you can consider it O(1).
func (c *command) Xrevrange(key interface{}, end, start string, count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XREVRANGE", key, end, start)
	if count != nil {
		c.encode("COUNT", count)
	}
	c.send(CmdXrevrange, r)
	return r
}

// Xtrim - Trims the stream to (approximately if '~' is passed) a certain size
// Group: stream
// Since: 5.0.0
// Complexity:
// O(N), with N being the number of evicted entries. Constant times are very small
// however, since entries are organized in macro nodes containing multiple entries that can
// be released with a single deallocation.
func (c *command) Xtrim(key interface{}, approx bool, count int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("XTRIM", key, "MAXLEN")
	if approx {
		c.encode("~")
	}
	c.encode(count)
	c.send(CmdXtrim, r)
	return r
}

// Zadd - Add one or more members to a sorted set, or update its score if it already exists
// Group: sorted_set
// Since: 1.2.0
// Complexity:
// O(log(N)) for each item added, where N is the number of elements in the sorted
// set.
func (c *command) Zadd(key interface{}, scoreMember []ScoreMember) Result {
	r := newAsyncResult()
	if scoreMember == nil {
		r.setErr(newInvalidValueError("scoreMember", nil))
		return r
	}
	c.mu.Lock()
	c.encode("ZADD", key)
	for _, v := range scoreMember {
		c.encode(v.Score, v.Member)
	}
	c.send(CmdZadd, r)
	return r
}

// ZaddCh - Add one or more members to a sorted set, or update its score if it already exists
// Group: sorted_set
// Since: 1.2.0
// Complexity:
// O(log(N)) for each item added, where N is the number of elements in the sorted
// set.
func (c *command) ZaddCh(key interface{}, scoreMember []ScoreMember) Result {
	r := newAsyncResult()
	if scoreMember == nil {
		r.setErr(newInvalidValueError("scoreMember", nil))
		return r
	}
	c.mu.Lock()
	c.encode("ZADD", key, "CH")
	for _, v := range scoreMember {
		c.encode(v.Score, v.Member)
	}
	c.send(CmdZaddCh, r)
	return r
}

// ZaddNx - Add one or more members to a sorted set, or update its score if it already exists
// Group: sorted_set
// Since: 1.2.0
// Complexity:
// O(log(N)) for each item added, where N is the number of elements in the sorted
// set.
func (c *command) ZaddNx(key interface{}, scoreMember []ScoreMember) Result {
	r := newAsyncResult()
	if scoreMember == nil {
		r.setErr(newInvalidValueError("scoreMember", nil))
		return r
	}
	c.mu.Lock()
	c.encode("ZADD", key, "NX")
	for _, v := range scoreMember {
		c.encode(v.Score, v.Member)
	}
	c.send(CmdZaddNx, r)
	return r
}

// ZaddXx - Add one or more members to a sorted set, or update its score if it already exists
// Group: sorted_set
// Since: 1.2.0
// Complexity:
// O(log(N)) for each item added, where N is the number of elements in the sorted
// set.
func (c *command) ZaddXx(key interface{}, scoreMember []ScoreMember) Result {
	r := newAsyncResult()
	if scoreMember == nil {
		r.setErr(newInvalidValueError("scoreMember", nil))
		return r
	}
	c.mu.Lock()
	c.encode("ZADD", key, "XX")
	for _, v := range scoreMember {
		c.encode(v.Score, v.Member)
	}
	c.send(CmdZaddXx, r)
	return r
}

// ZaddXxCh - Add one or more members to a sorted set, or update its score if it already exists
// Group: sorted_set
// Since: 1.2.0
// Complexity:
// O(log(N)) for each item added, where N is the number of elements in the sorted
// set.
func (c *command) ZaddXxCh(key interface{}, scoreMember []ScoreMember) Result {
	r := newAsyncResult()
	if scoreMember == nil {
		r.setErr(newInvalidValueError("scoreMember", nil))
		return r
	}
	c.mu.Lock()
	c.encode("ZADD", key, "XX", "CH")
	for _, v := range scoreMember {
		c.encode(v.Score, v.Member)
	}
	c.send(CmdZaddXxCh, r)
	return r
}

// Zcard - Get the number of members in a sorted set
// Group: sorted_set
// Since: 1.2.0
// Complexity: O(1)
func (c *command) Zcard(key interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZCARD", key)
	c.send(CmdZcard, r)
	return r
}

// Zcount - Count the members in a sorted set with scores within the given values
// Group: sorted_set
// Since: 2.0.0
// Complexity: O(log(N)) with N being the number of elements in the sorted set.
func (c *command) Zcount(key interface{}, min, max Zfloat64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZCOUNT", key, min, max)
	c.send(CmdZcount, r)
	return r
}

// Zincrby - Increment the score of a member in a sorted set
// Group: sorted_set
// Since: 1.2.0
// Complexity: O(log(N)) where N is the number of elements in the sorted set.
func (c *command) Zincrby(key interface{}, increment float64, member interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZINCRBY", key, increment, member)
	c.send(CmdZincrby, r)
	return r
}

// Zinterstore - Intersect multiple sorted sets and store the resulting sorted set in a new key
// Group: sorted_set
// Since: 2.0.0
// Complexity:
// O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K
// being the number of input sorted sets and M being the number of elements in the
// resulting sorted set.
func (c *command) Zinterstore(destination interface{}, numkeys int64, key []interface{}, weights []int64, aggregate *Aggregate) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("ZINTERSTORE", destination, numkeys)
	for _, v := range key {
		c.encode(v)
	}
	if weights != nil {
		c.encode("WEIGHTS")
		for _, v := range weights {
			c.encode(v)
		}
	}
	if aggregate != nil {
		c.encode("AGGREGATE", aggregate)
	}
	c.send(CmdZinterstore, r)
	return r
}

// Zlexcount - Count the number of members in a sorted set between a given lexicographical range
// Group: sorted_set
// Since: 2.8.9
// Complexity: O(log(N)) with N being the number of elements in the sorted set.
func (c *command) Zlexcount(key interface{}, min, max string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZLEXCOUNT", key, min, max)
	c.send(CmdZlexcount, r)
	return r
}

// Zpopmax - Remove and return members with the highest scores in a sorted set
// Group: sorted_set
// Since: 5.0.0
// Complexity:
// O(log(N)*M) with N being the number of elements in the sorted set, and M being
// the number of elements popped.
func (c *command) Zpopmax(key interface{}, count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZPOPMAX", key)
	if count != nil {
		c.encode(count)
	}
	c.send(CmdZpopmax, r)
	return r
}

// Zpopmin - Remove and return members with the lowest scores in a sorted set
// Group: sorted_set
// Since: 5.0.0
// Complexity:
// O(log(N)*M) with N being the number of elements in the sorted set, and M being
// the number of elements popped.
func (c *command) Zpopmin(key interface{}, count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZPOPMIN", key)
	if count != nil {
		c.encode(count)
	}
	c.send(CmdZpopmin, r)
	return r
}

// Zrange - Return a range of members in a sorted set, by index
// Group: sorted_set
// Since: 1.2.0
// Complexity:
// O(log(N)+M) with N being the number of elements in the sorted set and M the
// number of elements returned.
func (c *command) Zrange(key interface{}, start, stop int64, withscores bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZRANGE", key, start, stop)
	if withscores {
		c.encode("WITHSCORES")
	}
	c.send(CmdZrange, r)
	return r
}

// Zrangebylex - Return a range of members in a sorted set, by lexicographical range
// Group: sorted_set
// Since: 2.8.9
// Complexity:
// O(log(N)+M) with N being the number of elements in the sorted set and M the
// number of elements being returned. If M is constant (e.g. always asking for the first
// 10 elements with LIMIT), you can consider it O(log(N)).
func (c *command) Zrangebylex(key interface{}, min, max string, limit *OffsetCount) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZRANGEBYLEX", key, min, max)
	if limit != nil {
		c.encode("LIMIT", limit.Offset, limit.Count)
	}
	c.send(CmdZrangebylex, r)
	return r
}

// Zrangebyscore - Return a range of members in a sorted set, by score
// Group: sorted_set
// Since: 1.0.5
// Complexity:
// O(log(N)+M) with N being the number of elements in the sorted set and M the
// number of elements being returned. If M is constant (e.g. always asking for the first
// 10 elements with LIMIT), you can consider it O(log(N)).
func (c *command) Zrangebyscore(key interface{}, min, max Zfloat64, withscores bool, limit *OffsetCount) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZRANGEBYSCORE", key, min, max)
	if withscores {
		c.encode("WITHSCORES")
	}
	if limit != nil {
		c.encode("LIMIT", limit.Offset, limit.Count)
	}
	c.send(CmdZrangebyscore, r)
	return r
}

// Zrank - Determine the index of a member in a sorted set
// Group: sorted_set
// Since: 2.0.0
// Complexity: O(log(N))
func (c *command) Zrank(key, member interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZRANK", key, member)
	c.send(CmdZrank, r)
	return r
}

// Zrem - Remove one or more members from a sorted set
// Group: sorted_set
// Since: 1.2.0
// Complexity:
// O(M*log(N)) with N being the number of elements in the sorted set and M the
// number of elements to be removed.
func (c *command) Zrem(key interface{}, member []interface{}) Result {
	r := newAsyncResult()
	if member == nil {
		r.setErr(newInvalidValueError("member", nil))
		return r
	}
	c.mu.Lock()
	c.encode("ZREM", key)
	for _, v := range member {
		c.encode(v)
	}
	c.send(CmdZrem, r)
	return r
}

// Zremrangebylex - Remove all members in a sorted set between the given lexicographical range
// Group: sorted_set
// Since: 2.8.9
// Complexity:
// O(log(N)+M) with N being the number of elements in the sorted set and M the
// number of elements removed by the operation.
func (c *command) Zremrangebylex(key interface{}, min, max string) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZREMRANGEBYLEX", key, min, max)
	c.send(CmdZremrangebylex, r)
	return r
}

// Zremrangebyrank - Remove all members in a sorted set within the given indexes
// Group: sorted_set
// Since: 2.0.0
// Complexity:
// O(log(N)+M) with N being the number of elements in the sorted set and M the
// number of elements removed by the operation.
func (c *command) Zremrangebyrank(key interface{}, start, stop int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZREMRANGEBYRANK", key, start, stop)
	c.send(CmdZremrangebyrank, r)
	return r
}

// Zremrangebyscore - Remove all members in a sorted set within the given scores
// Group: sorted_set
// Since: 1.2.0
// Complexity:
// O(log(N)+M) with N being the number of elements in the sorted set and M the
// number of elements removed by the operation.
func (c *command) Zremrangebyscore(key interface{}, min, max Zfloat64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZREMRANGEBYSCORE", key, min, max)
	c.send(CmdZremrangebyscore, r)
	return r
}

// Zrevrange - Return a range of members in a sorted set, by index, with scores ordered from high to low
// Group: sorted_set
// Since: 1.2.0
// Complexity:
// O(log(N)+M) with N being the number of elements in the sorted set and M the
// number of elements returned.
func (c *command) Zrevrange(key interface{}, start, stop int64, withscores bool) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZREVRANGE", key, start, stop)
	if withscores {
		c.encode("WITHSCORES")
	}
	c.send(CmdZrevrange, r)
	return r
}

// Zrevrangebylex - Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.
// Group: sorted_set
// Since: 2.8.9
// Complexity:
// O(log(N)+M) with N being the number of elements in the sorted set and M the
// number of elements being returned. If M is constant (e.g. always asking for the first
// 10 elements with LIMIT), you can consider it O(log(N)).
func (c *command) Zrevrangebylex(key interface{}, max, min string, limit *OffsetCount) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZREVRANGEBYLEX", key, max, min)
	if limit != nil {
		c.encode("LIMIT", limit.Offset, limit.Count)
	}
	c.send(CmdZrevrangebylex, r)
	return r
}

// Zrevrangebyscore - Return a range of members in a sorted set, by score, with scores ordered from high to low
// Group: sorted_set
// Since: 2.2.0
// Complexity:
// O(log(N)+M) with N being the number of elements in the sorted set and M the
// number of elements being returned. If M is constant (e.g. always asking for the first
// 10 elements with LIMIT), you can consider it O(log(N)).
func (c *command) Zrevrangebyscore(key interface{}, max, min Zfloat64, withscores bool, limit *OffsetCount) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZREVRANGEBYSCORE", key, max, min)
	if withscores {
		c.encode("WITHSCORES")
	}
	if limit != nil {
		c.encode("LIMIT", limit.Offset, limit.Count)
	}
	c.send(CmdZrevrangebyscore, r)
	return r
}

// Zrevrank - Determine the index of a member in a sorted set, with scores ordered from high to low
// Group: sorted_set
// Since: 2.0.0
// Complexity: O(log(N))
func (c *command) Zrevrank(key, member interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZREVRANK", key, member)
	c.send(CmdZrevrank, r)
	return r
}

// Zscan - Incrementally iterate sorted sets elements and associated scores
// Group: sorted_set
// Since: 2.8.0
// Complexity:
// O(1) for every call. O(N) for a complete iteration, including enough command
// calls for the cursor to return back to 0. N is the number of elements inside the
// collection..
func (c *command) Zscan(key interface{}, cursor int64, match *string, count *int64) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZSCAN", key, cursor)
	if match != nil {
		c.encode("MATCH", match)
	}
	if count != nil {
		c.encode("COUNT", count)
	}
	c.send(CmdZscan, r)
	return r
}

// Zscore - Get the score associated with the given member in a sorted set
// Group: sorted_set
// Since: 1.2.0
// Complexity: O(1)
func (c *command) Zscore(key, member interface{}) Result {
	r := newAsyncResult()
	c.mu.Lock()
	c.encode("ZSCORE", key, member)
	c.send(CmdZscore, r)
	return r
}

// Zunionstore - Add multiple sorted sets and store the resulting sorted set in a new key
// Group: sorted_set
// Since: 2.0.0
// Complexity:
// O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets,
// and M being the number of elements in the resulting sorted set.
func (c *command) Zunionstore(destination interface{}, numkeys int64, key []interface{}, weights []int64, aggregate *Aggregate) Result {
	r := newAsyncResult()
	if key == nil {
		r.setErr(newInvalidValueError("key", nil))
		return r
	}
	c.mu.Lock()
	c.encode("ZUNIONSTORE", destination, numkeys)
	for _, v := range key {
		c.encode(v)
	}
	if weights != nil {
		c.encode("WEIGHTS")
		for _, v := range weights {
			c.encode(v)
		}
	}
	if aggregate != nil {
		c.encode("AGGREGATE", aggregate)
	}
	c.send(CmdZunionstore, r)
	return r
}

const (
	GroupCluster      = "Cluster"
	GroupConnection   = "Connection"
	GroupGeneric      = "Generic"
	GroupGeo          = "Geo"
	GroupHash         = "Hash"
	GroupHyperloglog  = "Hyperloglog"
	GroupList         = "List"
	GroupPubsub       = "Pubsub"
	GroupScripting    = "Scripting"
	GroupServer       = "Server"
	GroupSet          = "Set"
	GroupSortedSet    = "SortedSet"
	GroupStream       = "Stream"
	GroupString       = "String"
	GroupTransactions = "Transactions"
)

var Groups = map[string][]string{GroupCluster: {CmdClusterAddslots, CmdClusterBumpepoch, CmdClusterCountFailureReports, CmdClusterCountkeysinslot, CmdClusterDelslots, CmdClusterFailover, CmdClusterFlushslots, CmdClusterForget, CmdClusterGetkeysinslot, CmdClusterInfo, CmdClusterKeyslot, CmdClusterMeet, CmdClusterMyid, CmdClusterNodes, CmdClusterReplicas, CmdClusterReplicate, CmdClusterReset, CmdClusterSaveconfig, CmdClusterSetConfigEpoch, CmdClusterSetslotImporting, CmdClusterSetslotMigrating, CmdClusterSetslotNode, CmdClusterSetslotStable, CmdClusterSlaves, CmdClusterSlots, CmdReadonly, CmdReadwrite}, GroupConnection: {CmdAclCat, CmdAclDeluser, CmdAclGenpass, CmdAclGetuser, CmdAclHelp, CmdAclList, CmdAclLoad, CmdAclSave, CmdAclSetuser, CmdAclUsers, CmdAclWhoami, CmdAuth, CmdEcho, CmdHello, CmdPing, CmdQuit, CmdSelect, CmdSwapdb}, GroupGeneric: {CmdDel, CmdDo, CmdDump, CmdExists, CmdExpire, CmdExpireat, CmdKeys, CmdMigrate, CmdMove, CmdObjectEncoding, CmdObjectFreq, CmdObjectHelp, CmdObjectIdletime, CmdObjectRefcount, CmdPTTL, CmdPersist, CmdPexpire, CmdPexpireat, CmdRandomkey, CmdRename, CmdRenameNx, CmdRestore, CmdScan, CmdSort, CmdTTL, CmdTouch, CmdType, CmdUnlink, CmdWait}, GroupGeo: {CmdGeoadd, CmdGeodist, CmdGeohash, CmdGeopos, CmdGeoradius, CmdGeoradiusbymember}, GroupHash: {CmdHdel, CmdHexists, CmdHget, CmdHgetall, CmdHincrby, CmdHincrbyfloat, CmdHkeys, CmdHlen, CmdHmget, CmdHscan, CmdHset, CmdHsetNx, CmdHstrlen, CmdHvals}, GroupHyperloglog: {CmdPfadd, CmdPfcount, CmdPfmerge}, GroupList: {CmdBlpop, CmdBrpop, CmdBrpoplpush, CmdLindex, CmdLinsert, CmdLlen, CmdLpop, CmdLpush, CmdLpushx, CmdLrange, CmdLrem, CmdLset, CmdLtrim, CmdRpop, CmdRpoplpush, CmdRpush, CmdRpushx}, GroupPubsub: {CmdPsubscribe, CmdPublish, CmdPubsubChannels, CmdPubsubNumpat, CmdPubsubNumsub, CmdPunsubscribe, CmdSubscribe, CmdUnsubscribe}, GroupScripting: {CmdEval, CmdEvalsha, CmdScriptDebug, CmdScriptExists, CmdScriptFlush, CmdScriptKill, CmdScriptLoad}, GroupServer: {CmdBgrewriteaof, CmdBgsave, CmdClientGetname, CmdClientId, CmdClientKill, CmdClientList, CmdClientPause, CmdClientReply, CmdClientSetname, CmdClientTracking, CmdClientUnblock, CmdCommand, CmdCommandCount, CmdCommandGetkeys, CmdCommandInfo, CmdConfigGet, CmdConfigResetstat, CmdConfigRewrite, CmdConfigSet, CmdDbsize, CmdDebugObject, CmdDebugSegfault, CmdFlushall, CmdFlushdb, CmdInfo, CmdLastsave, CmdLatencyDoctor, CmdLatencyGraph, CmdLatencyHelp, CmdLatencyHistory, CmdLatencyLatest, CmdLatencyReset, CmdLolwut, CmdMemoryDoctor, CmdMemoryHelp, CmdMemoryMallocStats, CmdMemoryPurge, CmdMemoryStats, CmdMemoryUsage, CmdModuleList, CmdModuleLoad, CmdModuleUnload, CmdMonitor, CmdPsync, CmdReplicaof, CmdRole, CmdSave, CmdShutdown, CmdSlowlogGet, CmdSlowlogLen, CmdSlowlogReset, CmdTime}, GroupSet: {CmdSadd, CmdScard, CmdSdiff, CmdSdiffstore, CmdSinter, CmdSinterstore, CmdSismember, CmdSmembers, CmdSmove, CmdSpop, CmdSrandmember, CmdSrem, CmdSscan, CmdSunion, CmdSunionstore}, GroupSortedSet: {CmdBzpopmax, CmdBzpopmin, CmdZadd, CmdZaddCh, CmdZaddNx, CmdZaddXx, CmdZaddXxCh, CmdZcard, CmdZcount, CmdZincrby, CmdZinterstore, CmdZlexcount, CmdZpopmax, CmdZpopmin, CmdZrange, CmdZrangebylex, CmdZrangebyscore, CmdZrank, CmdZrem, CmdZremrangebylex, CmdZremrangebyrank, CmdZremrangebyscore, CmdZrevrange, CmdZrevrangebylex, CmdZrevrangebyscore, CmdZrevrank, CmdZscan, CmdZscore, CmdZunionstore}, GroupStream: {CmdXack, CmdXadd, CmdXclaim, CmdXdel, CmdXgroupCreate, CmdXgroupDelconsumer, CmdXgroupDestroy, CmdXgroupHelp, CmdXgroupSetid, CmdXinfoConsumers, CmdXinfoGroups, CmdXinfoHelp, CmdXinfoStream, CmdXlen, CmdXpending, CmdXrange, CmdXread, CmdXreadgroup, CmdXrevrange, CmdXtrim}, GroupString: {CmdAppend, CmdBitcount, CmdBitfield, CmdBitopAnd, CmdBitopNot, CmdBitopOr, CmdBitopXor, CmdBitpos, CmdDecr, CmdDecrby, CmdGet, CmdGetbit, CmdGetrange, CmdGetset, CmdIncr, CmdIncrby, CmdIncrbyfloat, CmdMget, CmdMset, CmdMsetNx, CmdSet, CmdSetEx, CmdSetExNx, CmdSetExXx, CmdSetNx, CmdSetPx, CmdSetPxNx, CmdSetPxXx, CmdSetXx, CmdSetbit, CmdSetrange, CmdStrlen}, GroupTransactions: {CmdDiscard, CmdExec, CmdMulti, CmdUnwatch, CmdWatch},
}

const (
	CmdAclCat                     = "AclCat"
	CmdAclDeluser                 = "AclDeluser"
	CmdAclGenpass                 = "AclGenpass"
	CmdAclGetuser                 = "AclGetuser"
	CmdAclHelp                    = "AclHelp"
	CmdAclList                    = "AclList"
	CmdAclLoad                    = "AclLoad"
	CmdAclSave                    = "AclSave"
	CmdAclSetuser                 = "AclSetuser"
	CmdAclUsers                   = "AclUsers"
	CmdAclWhoami                  = "AclWhoami"
	CmdAppend                     = "Append"
	CmdAuth                       = "Auth"
	CmdBgrewriteaof               = "Bgrewriteaof"
	CmdBgsave                     = "Bgsave"
	CmdBitcount                   = "Bitcount"
	CmdBitfield                   = "Bitfield"
	CmdBitopAnd                   = "BitopAnd"
	CmdBitopNot                   = "BitopNot"
	CmdBitopOr                    = "BitopOr"
	CmdBitopXor                   = "BitopXor"
	CmdBitpos                     = "Bitpos"
	CmdBlpop                      = "Blpop"
	CmdBrpop                      = "Brpop"
	CmdBrpoplpush                 = "Brpoplpush"
	CmdBzpopmax                   = "Bzpopmax"
	CmdBzpopmin                   = "Bzpopmin"
	CmdClientGetname              = "ClientGetname"
	CmdClientId                   = "ClientId"
	CmdClientKill                 = "ClientKill"
	CmdClientList                 = "ClientList"
	CmdClientPause                = "ClientPause"
	CmdClientReply                = "ClientReply"
	CmdClientSetname              = "ClientSetname"
	CmdClientTracking             = "ClientTracking"
	CmdClientUnblock              = "ClientUnblock"
	CmdClusterAddslots            = "ClusterAddslots"
	CmdClusterBumpepoch           = "ClusterBumpepoch"
	CmdClusterCountFailureReports = "ClusterCountFailureReports"
	CmdClusterCountkeysinslot     = "ClusterCountkeysinslot"
	CmdClusterDelslots            = "ClusterDelslots"
	CmdClusterFailover            = "ClusterFailover"
	CmdClusterFlushslots          = "ClusterFlushslots"
	CmdClusterForget              = "ClusterForget"
	CmdClusterGetkeysinslot       = "ClusterGetkeysinslot"
	CmdClusterInfo                = "ClusterInfo"
	CmdClusterKeyslot             = "ClusterKeyslot"
	CmdClusterMeet                = "ClusterMeet"
	CmdClusterMyid                = "ClusterMyid"
	CmdClusterNodes               = "ClusterNodes"
	CmdClusterReplicas            = "ClusterReplicas"
	CmdClusterReplicate           = "ClusterReplicate"
	CmdClusterReset               = "ClusterReset"
	CmdClusterSaveconfig          = "ClusterSaveconfig"
	CmdClusterSetConfigEpoch      = "ClusterSetConfigEpoch"
	CmdClusterSetslotImporting    = "ClusterSetslotImporting"
	CmdClusterSetslotMigrating    = "ClusterSetslotMigrating"
	CmdClusterSetslotNode         = "ClusterSetslotNode"
	CmdClusterSetslotStable       = "ClusterSetslotStable"
	CmdClusterSlaves              = "ClusterSlaves"
	CmdClusterSlots               = "ClusterSlots"
	CmdCommand                    = "Command"
	CmdCommandCount               = "CommandCount"
	CmdCommandGetkeys             = "CommandGetkeys"
	CmdCommandInfo                = "CommandInfo"
	CmdConfigGet                  = "ConfigGet"
	CmdConfigResetstat            = "ConfigResetstat"
	CmdConfigRewrite              = "ConfigRewrite"
	CmdConfigSet                  = "ConfigSet"
	CmdDbsize                     = "Dbsize"
	CmdDebugObject                = "DebugObject"
	CmdDebugSegfault              = "DebugSegfault"
	CmdDecr                       = "Decr"
	CmdDecrby                     = "Decrby"
	CmdDel                        = "Del"
	CmdDiscard                    = "Discard"
	CmdDo                         = "Do"
	CmdDump                       = "Dump"
	CmdEcho                       = "Echo"
	CmdEval                       = "Eval"
	CmdEvalsha                    = "Evalsha"
	CmdExec                       = "Exec"
	CmdExists                     = "Exists"
	CmdExpire                     = "Expire"
	CmdExpireat                   = "Expireat"
	CmdFlushall                   = "Flushall"
	CmdFlushdb                    = "Flushdb"
	CmdGeoadd                     = "Geoadd"
	CmdGeodist                    = "Geodist"
	CmdGeohash                    = "Geohash"
	CmdGeopos                     = "Geopos"
	CmdGeoradius                  = "Georadius"
	CmdGeoradiusbymember          = "Georadiusbymember"
	CmdGet                        = "Get"
	CmdGetbit                     = "Getbit"
	CmdGetrange                   = "Getrange"
	CmdGetset                     = "Getset"
	CmdHdel                       = "Hdel"
	CmdHello                      = "Hello"
	CmdHexists                    = "Hexists"
	CmdHget                       = "Hget"
	CmdHgetall                    = "Hgetall"
	CmdHincrby                    = "Hincrby"
	CmdHincrbyfloat               = "Hincrbyfloat"
	CmdHkeys                      = "Hkeys"
	CmdHlen                       = "Hlen"
	CmdHmget                      = "Hmget"
	CmdHscan                      = "Hscan"
	CmdHset                       = "Hset"
	CmdHsetNx                     = "HsetNx"
	CmdHstrlen                    = "Hstrlen"
	CmdHvals                      = "Hvals"
	CmdIncr                       = "Incr"
	CmdIncrby                     = "Incrby"
	CmdIncrbyfloat                = "Incrbyfloat"
	CmdInfo                       = "Info"
	CmdKeys                       = "Keys"
	CmdLastsave                   = "Lastsave"
	CmdLatencyDoctor              = "LatencyDoctor"
	CmdLatencyGraph               = "LatencyGraph"
	CmdLatencyHelp                = "LatencyHelp"
	CmdLatencyHistory             = "LatencyHistory"
	CmdLatencyLatest              = "LatencyLatest"
	CmdLatencyReset               = "LatencyReset"
	CmdLindex                     = "Lindex"
	CmdLinsert                    = "Linsert"
	CmdLlen                       = "Llen"
	CmdLolwut                     = "Lolwut"
	CmdLpop                       = "Lpop"
	CmdLpush                      = "Lpush"
	CmdLpushx                     = "Lpushx"
	CmdLrange                     = "Lrange"
	CmdLrem                       = "Lrem"
	CmdLset                       = "Lset"
	CmdLtrim                      = "Ltrim"
	CmdMemoryDoctor               = "MemoryDoctor"
	CmdMemoryHelp                 = "MemoryHelp"
	CmdMemoryMallocStats          = "MemoryMallocStats"
	CmdMemoryPurge                = "MemoryPurge"
	CmdMemoryStats                = "MemoryStats"
	CmdMemoryUsage                = "MemoryUsage"
	CmdMget                       = "Mget"
	CmdMigrate                    = "Migrate"
	CmdModuleList                 = "ModuleList"
	CmdModuleLoad                 = "ModuleLoad"
	CmdModuleUnload               = "ModuleUnload"
	CmdMonitor                    = "Monitor"
	CmdMove                       = "Move"
	CmdMset                       = "Mset"
	CmdMsetNx                     = "MsetNx"
	CmdMulti                      = "Multi"
	CmdObjectEncoding             = "ObjectEncoding"
	CmdObjectFreq                 = "ObjectFreq"
	CmdObjectHelp                 = "ObjectHelp"
	CmdObjectIdletime             = "ObjectIdletime"
	CmdObjectRefcount             = "ObjectRefcount"
	CmdPTTL                       = "PTTL"
	CmdPersist                    = "Persist"
	CmdPexpire                    = "Pexpire"
	CmdPexpireat                  = "Pexpireat"
	CmdPfadd                      = "Pfadd"
	CmdPfcount                    = "Pfcount"
	CmdPfmerge                    = "Pfmerge"
	CmdPing                       = "Ping"
	CmdPsubscribe                 = "Psubscribe"
	CmdPsync                      = "Psync"
	CmdPublish                    = "Publish"
	CmdPubsubChannels             = "PubsubChannels"
	CmdPubsubNumpat               = "PubsubNumpat"
	CmdPubsubNumsub               = "PubsubNumsub"
	CmdPunsubscribe               = "Punsubscribe"
	CmdQuit                       = "Quit"
	CmdRandomkey                  = "Randomkey"
	CmdReadonly                   = "Readonly"
	CmdReadwrite                  = "Readwrite"
	CmdRename                     = "Rename"
	CmdRenameNx                   = "RenameNx"
	CmdReplicaof                  = "Replicaof"
	CmdRestore                    = "Restore"
	CmdRole                       = "Role"
	CmdRpop                       = "Rpop"
	CmdRpoplpush                  = "Rpoplpush"
	CmdRpush                      = "Rpush"
	CmdRpushx                     = "Rpushx"
	CmdSadd                       = "Sadd"
	CmdSave                       = "Save"
	CmdScan                       = "Scan"
	CmdScard                      = "Scard"
	CmdScriptDebug                = "ScriptDebug"
	CmdScriptExists               = "ScriptExists"
	CmdScriptFlush                = "ScriptFlush"
	CmdScriptKill                 = "ScriptKill"
	CmdScriptLoad                 = "ScriptLoad"
	CmdSdiff                      = "Sdiff"
	CmdSdiffstore                 = "Sdiffstore"
	CmdSelect                     = "Select"
	CmdSet                        = "Set"
	CmdSetEx                      = "SetEx"
	CmdSetExNx                    = "SetExNx"
	CmdSetExXx                    = "SetExXx"
	CmdSetNx                      = "SetNx"
	CmdSetPx                      = "SetPx"
	CmdSetPxNx                    = "SetPxNx"
	CmdSetPxXx                    = "SetPxXx"
	CmdSetXx                      = "SetXx"
	CmdSetbit                     = "Setbit"
	CmdSetrange                   = "Setrange"
	CmdShutdown                   = "Shutdown"
	CmdSinter                     = "Sinter"
	CmdSinterstore                = "Sinterstore"
	CmdSismember                  = "Sismember"
	CmdSlowlogGet                 = "SlowlogGet"
	CmdSlowlogLen                 = "SlowlogLen"
	CmdSlowlogReset               = "SlowlogReset"
	CmdSmembers                   = "Smembers"
	CmdSmove                      = "Smove"
	CmdSort                       = "Sort"
	CmdSpop                       = "Spop"
	CmdSrandmember                = "Srandmember"
	CmdSrem                       = "Srem"
	CmdSscan                      = "Sscan"
	CmdStrlen                     = "Strlen"
	CmdSubscribe                  = "Subscribe"
	CmdSunion                     = "Sunion"
	CmdSunionstore                = "Sunionstore"
	CmdSwapdb                     = "Swapdb"
	CmdTTL                        = "TTL"
	CmdTime                       = "Time"
	CmdTouch                      = "Touch"
	CmdType                       = "Type"
	CmdUnlink                     = "Unlink"
	CmdUnsubscribe                = "Unsubscribe"
	CmdUnwatch                    = "Unwatch"
	CmdWait                       = "Wait"
	CmdWatch                      = "Watch"
	CmdXack                       = "Xack"
	CmdXadd                       = "Xadd"
	CmdXclaim                     = "Xclaim"
	CmdXdel                       = "Xdel"
	CmdXgroupCreate               = "XgroupCreate"
	CmdXgroupDelconsumer          = "XgroupDelconsumer"
	CmdXgroupDestroy              = "XgroupDestroy"
	CmdXgroupHelp                 = "XgroupHelp"
	CmdXgroupSetid                = "XgroupSetid"
	CmdXinfoConsumers             = "XinfoConsumers"
	CmdXinfoGroups                = "XinfoGroups"
	CmdXinfoHelp                  = "XinfoHelp"
	CmdXinfoStream                = "XinfoStream"
	CmdXlen                       = "Xlen"
	CmdXpending                   = "Xpending"
	CmdXrange                     = "Xrange"
	CmdXread                      = "Xread"
	CmdXreadgroup                 = "Xreadgroup"
	CmdXrevrange                  = "Xrevrange"
	CmdXtrim                      = "Xtrim"
	CmdZadd                       = "Zadd"
	CmdZaddCh                     = "ZaddCh"
	CmdZaddNx                     = "ZaddNx"
	CmdZaddXx                     = "ZaddXx"
	CmdZaddXxCh                   = "ZaddXxCh"
	CmdZcard                      = "Zcard"
	CmdZcount                     = "Zcount"
	CmdZincrby                    = "Zincrby"
	CmdZinterstore                = "Zinterstore"
	CmdZlexcount                  = "Zlexcount"
	CmdZpopmax                    = "Zpopmax"
	CmdZpopmin                    = "Zpopmin"
	CmdZrange                     = "Zrange"
	CmdZrangebylex                = "Zrangebylex"
	CmdZrangebyscore              = "Zrangebyscore"
	CmdZrank                      = "Zrank"
	CmdZrem                       = "Zrem"
	CmdZremrangebylex             = "Zremrangebylex"
	CmdZremrangebyrank            = "Zremrangebyrank"
	CmdZremrangebyscore           = "Zremrangebyscore"
	CmdZrevrange                  = "Zrevrange"
	CmdZrevrangebylex             = "Zrevrangebylex"
	CmdZrevrangebyscore           = "Zrevrangebyscore"
	CmdZrevrank                   = "Zrevrank"
	CmdZscan                      = "Zscan"
	CmdZscore                     = "Zscore"
	CmdZunionstore                = "Zunionstore"
)

var CommandNames = []string{CmdAclCat, CmdAclDeluser, CmdAclGenpass, CmdAclGetuser, CmdAclHelp, CmdAclList, CmdAclLoad, CmdAclSave, CmdAclSetuser, CmdAclUsers, CmdAclWhoami, CmdAppend, CmdAuth, CmdBgrewriteaof, CmdBgsave, CmdBitcount, CmdBitfield, CmdBitopAnd, CmdBitopNot, CmdBitopOr, CmdBitopXor, CmdBitpos, CmdBlpop, CmdBrpop, CmdBrpoplpush, CmdBzpopmax, CmdBzpopmin, CmdClientGetname, CmdClientId, CmdClientKill, CmdClientList, CmdClientPause, CmdClientReply, CmdClientSetname, CmdClientTracking, CmdClientUnblock, CmdClusterAddslots, CmdClusterBumpepoch, CmdClusterCountFailureReports, CmdClusterCountkeysinslot, CmdClusterDelslots, CmdClusterFailover, CmdClusterFlushslots, CmdClusterForget, CmdClusterGetkeysinslot, CmdClusterInfo, CmdClusterKeyslot, CmdClusterMeet, CmdClusterMyid, CmdClusterNodes, CmdClusterReplicas, CmdClusterReplicate, CmdClusterReset, CmdClusterSaveconfig, CmdClusterSetConfigEpoch, CmdClusterSetslotImporting, CmdClusterSetslotMigrating, CmdClusterSetslotNode, CmdClusterSetslotStable, CmdClusterSlaves, CmdClusterSlots, CmdCommand, CmdCommandCount, CmdCommandGetkeys, CmdCommandInfo, CmdConfigGet, CmdConfigResetstat, CmdConfigRewrite, CmdConfigSet, CmdDbsize, CmdDebugObject, CmdDebugSegfault, CmdDecr, CmdDecrby, CmdDel, CmdDiscard, CmdDo, CmdDump, CmdEcho, CmdEval, CmdEvalsha, CmdExec, CmdExists, CmdExpire, CmdExpireat, CmdFlushall, CmdFlushdb, CmdGeoadd, CmdGeodist, CmdGeohash, CmdGeopos, CmdGeoradius, CmdGeoradiusbymember, CmdGet, CmdGetbit, CmdGetrange, CmdGetset, CmdHdel, CmdHello, CmdHexists, CmdHget, CmdHgetall, CmdHincrby, CmdHincrbyfloat, CmdHkeys, CmdHlen, CmdHmget, CmdHscan, CmdHset, CmdHsetNx, CmdHstrlen, CmdHvals, CmdIncr, CmdIncrby, CmdIncrbyfloat, CmdInfo, CmdKeys, CmdLastsave, CmdLatencyDoctor, CmdLatencyGraph, CmdLatencyHelp, CmdLatencyHistory, CmdLatencyLatest, CmdLatencyReset, CmdLindex, CmdLinsert, CmdLlen, CmdLolwut, CmdLpop, CmdLpush, CmdLpushx, CmdLrange, CmdLrem, CmdLset, CmdLtrim, CmdMemoryDoctor, CmdMemoryHelp, CmdMemoryMallocStats, CmdMemoryPurge, CmdMemoryStats, CmdMemoryUsage, CmdMget, CmdMigrate, CmdModuleList, CmdModuleLoad, CmdModuleUnload, CmdMonitor, CmdMove, CmdMset, CmdMsetNx, CmdMulti, CmdObjectEncoding, CmdObjectFreq, CmdObjectHelp, CmdObjectIdletime, CmdObjectRefcount, CmdPTTL, CmdPersist, CmdPexpire, CmdPexpireat, CmdPfadd, CmdPfcount, CmdPfmerge, CmdPing, CmdPsubscribe, CmdPsync, CmdPublish, CmdPubsubChannels, CmdPubsubNumpat, CmdPubsubNumsub, CmdPunsubscribe, CmdQuit, CmdRandomkey, CmdReadonly, CmdReadwrite, CmdRename, CmdRenameNx, CmdReplicaof, CmdRestore, CmdRole, CmdRpop, CmdRpoplpush, CmdRpush, CmdRpushx, CmdSadd, CmdSave, CmdScan, CmdScard, CmdScriptDebug, CmdScriptExists, CmdScriptFlush, CmdScriptKill, CmdScriptLoad, CmdSdiff, CmdSdiffstore, CmdSelect, CmdSet, CmdSetEx, CmdSetExNx, CmdSetExXx, CmdSetNx, CmdSetPx, CmdSetPxNx, CmdSetPxXx, CmdSetXx, CmdSetbit, CmdSetrange, CmdShutdown, CmdSinter, CmdSinterstore, CmdSismember, CmdSlowlogGet, CmdSlowlogLen, CmdSlowlogReset, CmdSmembers, CmdSmove, CmdSort, CmdSpop, CmdSrandmember, CmdSrem, CmdSscan, CmdStrlen, CmdSubscribe, CmdSunion, CmdSunionstore, CmdSwapdb, CmdTTL, CmdTime, CmdTouch, CmdType, CmdUnlink, CmdUnsubscribe, CmdUnwatch, CmdWait, CmdWatch, CmdXack, CmdXadd, CmdXclaim, CmdXdel, CmdXgroupCreate, CmdXgroupDelconsumer, CmdXgroupDestroy, CmdXgroupHelp, CmdXgroupSetid, CmdXinfoConsumers, CmdXinfoGroups, CmdXinfoHelp, CmdXinfoStream, CmdXlen, CmdXpending, CmdXrange, CmdXread, CmdXreadgroup, CmdXrevrange, CmdXtrim, CmdZadd, CmdZaddCh, CmdZaddNx, CmdZaddXx, CmdZaddXxCh, CmdZcard, CmdZcount, CmdZincrby, CmdZinterstore, CmdZlexcount, CmdZpopmax, CmdZpopmin, CmdZrange, CmdZrangebylex, CmdZrangebyscore, CmdZrank, CmdZrem, CmdZremrangebylex, CmdZremrangebyrank, CmdZremrangebyscore, CmdZrevrange, CmdZrevrangebylex, CmdZrevrangebyscore, CmdZrevrank, CmdZscan, CmdZscore, CmdZunionstore}
